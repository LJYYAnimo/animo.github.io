<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mybatis源码分析</title>
      <link href="/3036077991.html"/>
      <url>/3036077991.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>Mybatis执行顺序、Mybatis源码分析、MyBatis SqlSessionFactoryBuilder、Mybatis多数据源切换、Mybatis一级缓存问题、Mybatis二级缓存如何使用。 </p></blockquote><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。  </p></blockquote><h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><p>Pom和Mybatis配置可以看<a href="http://www.ljyanimo.com/1345018663.html">这里</a>  </p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>{</span><br><span class="line">    <span class="function">UserEntity <span class="title">getById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(UserEntity userEntity)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mybatis_resource`</span>.<span class="string">`无标题`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">7</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></tbody></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><blockquote><p>这里单独使用Mybatis进行分析不集成其他框架，使用Main方法进行测试。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line"></span><br><span class="line">    String resource =  <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line"></span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession()){</span><br><span class="line"></span><br><span class="line">        UserEntity userEntity = sqlSession.selectOne(<span class="string">"com.animo.mybatis.source.mapper.UserMapper.getById"</span>,<span class="number">17</span>);</span><br><span class="line">        </span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(userMapper.getById(<span class="number">1</span>).toString());</span><br><span class="line"></span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line"></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>代码中实现了Mybatis的整个流程，从初始化到获取Mapper然后执行我们自定义的方法，下面我给出大致的流程图。  </p></blockquote><p><img alt data-src="/img/mybatis/jdlct.png" class="lozad">  </p><h2 id="获取SqlSessionFactory"><a href="#获取SqlSessionFactory" class="headerlink" title="获取SqlSessionFactory"></a>获取SqlSessionFactory</h2><blockquote><p>主要针对于new SqlSessionFactoryBuilder().build(inputStream);这个方法进行分析，入参是输入流也就是读取的配置文件xml。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        inputStream.close();</span><br><span class="line">      } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> InputStream 文件输入流<br> environment 数据源ID<br> Properties 额外配置文件  </p><blockquote><p>这里初始化了一个XMLConfigBuilder，主要作用于解析Mybatis的xml配置文件。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">"SQL Mapper Configuration"</span>);</span><br><span class="line">    <span class="keyword">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="keyword">this</span>.parsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    <span class="keyword">this</span>.parser = parser;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>XPathParser 存放着整个配置文件节点  </p><blockquote><p>在BaseBuilder父类中初始化了一个Configuration主要存放配置文件的内容。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BaseBuilder(Configuration configuration) {</span><br><span class="line">    this.configuration = configuration;</span><br><span class="line">    this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();</span><br><span class="line">    this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>typeAliasRegistry、typeHandlerRegistry在构造方法中都做了一些默认的初始化配置，主要是针对基础数据类型和包装类还有一些常用的集合进行别名设置和类型转换。<br>在执行完XMLConfigBuilder构造方法初始化之后，调用了parse()方法进行xml解析，其内部是通过configuration进行装配各种配置。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() {</span><br><span class="line">    if (parsed) {</span><br><span class="line">      throw new BuilderException("Each XMLConfigBuilder can only be used once.");</span><br><span class="line">    }</span><br><span class="line">    parsed = true;</span><br><span class="line">    parseConfiguration(parser.evalNode("/configuration"));</span><br><span class="line">    return configuration;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>parsed在上面初始化的时候赋值为false，就是为了防止同一个XMLConfigBuilder多次使用。<br>parseConfiguration(parser.evalNode(“/configuration”));这里可以看出主节点是从configuration开始。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>根据上面提供的配置文件最终会走的解析方法只有两个，environmentsElement(root.evalNode(“environments”));mapperElement(root.evalNode(“mappers”));</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (environment == <span class="keyword">null</span>) {</span><br><span class="line">        environment = context.getStringAttribute(<span class="string">"default"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">for</span> (XNode child : context.getChildren()) {</span><br><span class="line">        String id = child.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isSpecifiedEnvironment(id)) {</span><br><span class="line">          TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class="string">"transactionManager"</span>));</span><br><span class="line">          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="string">"dataSource"</span>));</span><br><span class="line">          DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">          Environment.Builder environmentBuilder = <span class="keyword">new</span> Environment.Builder(id)</span><br><span class="line">              .transactionFactory(txFactory)</span><br><span class="line">              .dataSource(dataSource);</span><br><span class="line">          configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"># TransactionFactory、DataSourceFactory</span><br><span class="line">根据节点type属性来初始化。</span><br></pre></td></tr></tbody></table></figure><blockquote><p>environment就是入参时说的数据源节点，这里如果为空的情况下会走environments节点属性的默认值，所以默认值要与其中另一一个子节点数据源的ID匹配，否则无法加载数据源到configuration中，其次就是两个数据源相同时就会进行顺序覆盖。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpecifiedEnvironment</span><span class="params">(String id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"No environment specified."</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Environment requires an id attribute."</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (environment.equals(id)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>isSpecifiedEnvironment方法主要判断当前子节点数据源ID与获取的默认值或者传入过来的ID是否匹配。<br>TransactionFactory 实现类 JdbcTransactionFactory。<br>DataSourceFactory 实现类 PooledDataSourceFactory。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>DataSource 实现类 PooledDataSource。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Environment</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionFactory transactionFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Environment对应数据源主要里面存储了数据源Id、事务管理器、数据源。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) {</span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> && url == <span class="keyword">null</span> && mapperClass == <span class="keyword">null</span>) {</span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> && url != <span class="keyword">null</span> && mapperClass == <span class="keyword">null</span>) {</span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> && url == <span class="keyword">null</span> && mapperClass != <span class="keyword">null</span>) {</span><br><span class="line">            Class<?> mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于没有配置package节点所以会走else，判断mapper节点的内容。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>根据提供的配置只有resource属性是存在的，resource！=null;url =null;mapperClass = null;  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resource != <span class="keyword">null</span> && url == <span class="keyword">null</span> && mapperClass == <span class="keyword">null</span>) {</span><br><span class="line">    ErrorContext.instance().resource(resource);</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">    mapperParser.parse();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Resources.getResourceAsStream(resource);读取UserMapper.xml，有没有感觉和XMLConfigBuilder类似，可以把XMLConfigBuilder看做是对配置文件的整体，其他的是针对于其他配置文件的解析。（XMLMapperBuilder）  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">XMLMapperBuilder</span><span class="params">(XPathParser parser, Configuration configuration, String resource, Map<String, XNode> sqlFragments)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(configuration);</span><br><span class="line">    <span class="keyword">this</span>.builderAssistant = <span class="keyword">new</span> MapperBuilderAssistant(configuration, resource);</span><br><span class="line">    <span class="keyword">this</span>.parser = parser;</span><br><span class="line">    <span class="keyword">this</span>.sqlFragments = sqlFragments;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里XMLMapperBuilder同样也继承于BaseBuilder。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) {</span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 不会进入</span></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里已经是进入到mapper.xml内部进行解析。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!configuration.isResourceLoaded(resource)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在运行期间单个mapper只会解析一次。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">      <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">      }</span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">      cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">      cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">      parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">      resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">      sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于在mapper下的子节点只配置了crud的标签所以只能进入最后一个方法buildStatementFromContext(context.evalNodes(“select|insert|update|delete”));  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List<XNode> list)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) {</span><br><span class="line">      buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    }</span><br><span class="line">    buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>databaseId在解析mybatis配置的时候设置，通过这个方法databaseIdProviderElement(root.evalNode(“databaseIdProvider”));<br>DatabaseId是数据库厂商标识符，例如：mysql、oracle、sqlserver等。使用教程: <a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider" target="_blank" rel="noopener">databaseIdProvider</a>  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List<XNode> list, String requiredDatabaseId)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) {</span><br><span class="line">      <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      } <span class="keyword">catch</span> (IncompleteElementException e) {</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 节点 id 属性</span></span><br><span class="line">  String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">  String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 获取节点标签名称</span></span><br><span class="line">  String nodeName = context.getNode().getNodeName();</span><br><span class="line">  <span class="comment">// 为枚举类主要就是CRUD的名称</span></span><br><span class="line">  SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">  <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT; </span><br><span class="line">  <span class="comment">// flushCache将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</span></span><br><span class="line">  <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">  <span class="comment">// useCache将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true</span></span><br><span class="line">  <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">  <span class="comment">// resultOrdered这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 </span></span><br><span class="line">  <span class="comment">// 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：false。</span></span><br><span class="line">  <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">  XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">  includeParser.applyIncludes(context.getNode());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取结果集</span></span><br><span class="line">  String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 会先去存放别名的hashmap里面查找，如果没有则调用反射初始化</span></span><br><span class="line">  Class<?> parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">  String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">  LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">  processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the SQL (pre: <selectKey> and <include> were parsed and removed)</span></span><br><span class="line">  KeyGenerator keyGenerator;</span><br><span class="line">  String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) {</span><br><span class="line">    keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">        configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">  }</span><br><span class="line">  SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">  StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">  Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">  Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">  String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">  String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">  Class<?> resultTypeClass = resolveClass(resultType);</span><br><span class="line">  String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">  String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">  ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">  <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) {</span><br><span class="line">    resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">  }</span><br><span class="line">  String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">  String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">  String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line"></span><br><span class="line">  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">      resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>每个对应的数据库的标签信息都会对应一个MappedStatement，然后存放在mappedStatements.put(ms.getId(), ms);把方法全限定命名当做key，然后把信息当做value给缓存起来。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>{</span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) {</span><br><span class="line">      Class<?> boundType = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        boundType = Resources.classForName(namespace);</span><br><span class="line">      } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">        <span class="comment">//ignore, bound type is not required</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasMapper(boundType)) {</span><br><span class="line">          configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">          configuration.addMapper(boundType);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在整个解析流程之后进入到bindMapperForNamespace方法中，主要是对mapper对象进行保存。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <T> void addMapper(Class<T> type) {</span><br><span class="line">    //判断当前类是否为接口，只有mapper接口才能被绑定</span><br><span class="line">    if (type.isInterface()) {</span><br><span class="line">     // 判断该mapper有没有被绑定</span><br><span class="line">      if (hasMapper(type)) {</span><br><span class="line">        throw new BindingException("Type " + type + " is already known to the MapperRegistry.");</span><br><span class="line">      }</span><br><span class="line">      // 临时变量安全保障</span><br><span class="line">      boolean loadCompleted = false;</span><br><span class="line">      try {</span><br><span class="line">        knownMappers.put(type, new MapperProxyFactory<>(type));</span><br><span class="line">        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = true;</span><br><span class="line">      } finally {</span><br><span class="line">        if (!loadCompleted) {</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>knownMappers缓存着mapper以及MapperProxyFactory，MapperProxyFactory存储着Mapper接口和缓存的方法，里面核心方法就是生成代理对象。    </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) {</span><br><span class="line">    return new DefaultSqlSessionFactory(config);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在走完所有解析之后返回SqlSessionFactory（DefaultSqlSessionFactory);   </p></blockquote><p><img alt data-src="/img/mybatis/sqlsessionFactory.png" class="lozad">  </p><h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><blockquote><p>SqlSession生命周期在于方法内部，也就是单个请求执行之后就销毁，SqlSession作用于数据库交互。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用无参的openSession方法获取SqlSession，configuration.getDefaultExecutorType()也就是默认执行器走的是SIMPLE。    </p></blockquote><ol><li>ExecutorType.SIMPLE：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。</li><li>ExecutorType.REUSE：该类型的执行器会复用预处理语句。</li><li>ExecutorType.BATCH：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。  </li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>{</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 获取数据源</span></span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>{</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) {</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) {</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) {</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    }</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>executorType为SIMPLE类型也就是会创建SimpleExecutor。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>cacheEnabled默认为true，这是二级缓存的开关，由于默认开启所以创建了二级缓存执行器，把一级缓存放入了二级缓存，这里属于装饰者模式。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CachingExecutor</span><span class="params">(Executor delegate)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    delegate.setExecutorWrapper(<span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>截取了一小段代码，里面delegate执行器就是代表一级缓存，也就是在构造方法中传递过来的执行器。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="keyword">boolean</span> autoCommit)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.autoCommit = autoCommit;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>所以我们的SqlSession实际上走的是DefaultSqlSession实现类，然后里面最重要的是执行器，也就是设置的二级缓存执行器里面包含了一级缓存。  </p></blockquote><h2 id="获取Mapper"><a href="#获取Mapper" class="headerlink" title="获取Mapper"></a>获取Mapper</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在java中都知道接口是不能实例化的，所以这里肯定是使用jdk动态代理实现。 </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <T> <span class="function">T <span class="title">getMapper</span><span class="params">(Class<T> type, SqlSession sqlSession)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这是Configuration中的方法获取Mapper，然而我们在哪里设置的呢？这就是上面初始化的时候，Mapper.xml中的标签都被设置进MappedStatement之后，进行的Mapper绑定也就是被绑定到了knownMappers中。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <T> <span class="function">T <span class="title">getMapper</span><span class="params">(Class<T> type, SqlSession sqlSession)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>mapperProxyFactory生成Mapper代理类。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> MapperProxy<T> mapperProxy = <span class="keyword">new</span> MapperProxy<>(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy<T> mapperProxy)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] { mapperInterface }, mapperProxy);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>MapperProxy实现了JDK动态代理的接口，所以我们的Mapper执行方法都会经过这里，这时候Mapper代理类就已经生成了。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>代理类保存了SqlSession（里面主要是执行器和配置文件）、当前代理的接口、和缓存的方法这里为空。  </p></blockquote><h2 id="方法执行过程"><a href="#方法执行过程" class="headerlink" title="方法执行过程"></a>方法执行过程</h2><blockquote><p>如果不明白代理设计模式的话可以看我往期写的<a href="http://www.ljyanimo.com/2423943376.html">代理设计模式</a>。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>{</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) {</span><br><span class="line">        <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) {</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>cachedMapperMethod(method);把当前方法缓存在内存中。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>{</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) {</span><br><span class="line">      <span class="keyword">case</span> INSERT: {</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">case</span> UPDATE: {</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">case</span> DELETE: {</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() && method.hasResultHandler()) {</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) {</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) {</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) {</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              && (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) {</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> && method.getReturnType().isPrimitive() && !method.returnsVoid()) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>command.getType()在缓存方法时候设置了，里面有两个参数一个是name（方法全限定名称）、第二个type（SqlCommandType枚举类型也就是mapper.xml中的标签）。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SELECT:</span><br><span class="line">    <span class="keyword">if</span> (method.returnsVoid() && method.hasResultHandler()) {</span><br><span class="line">      executeWithResultHandler(sqlSession, args);</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) {</span><br><span class="line">      result = executeForMany(sqlSession, args);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) {</span><br><span class="line">      result = executeForMap(sqlSession, args);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) {</span><br><span class="line">      result = executeForCursor(sqlSession, args);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">          && (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) {</span><br><span class="line">        result = Optional.ofNullable(result);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><ol><li>在上面的switch中我们最终进入到了SELECT，在if判断中的条件都没有配置所以最终走了个else，可以看出最后面还是使用sqlSession去操作。  </li><li>sqlSession.selectOne(command.getName(), param);中第一个参数就是当前方法的全限定名称，第二个就是我们传入的参数了。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <T> <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>{</span><br><span class="line">    List<T> list = <span class="keyword">this</span>.selectList(statement, parameter);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (list.size() > <span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里的话通过判断list的size来规约查询一条数据，如果多条就报错。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <E> <span class="function">List<E> <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">}</span><br><span class="line"># 为了简短这里截取了部分代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RowBounds</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_ROW_OFFSET = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_ROW_LIMIT = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RowBounds DEFAULT = <span class="keyword">new</span> RowBounds();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RowBounds</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.offset = NO_ROW_OFFSET;</span><br><span class="line">    <span class="keyword">this</span>.limit = NO_ROW_LIMIT;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>RowBounds这个是一个分页类型，默认第一页然后最大查询记录是Integer的最大值。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <E> <span class="function">List<E> <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>之前在对mapper.xml读取的时候已经把每个方法的全限定命名当做id保存起来了，所以这边获取到的MappedStatement就是单个标签的内容。  </li><li>executor代表CachingExecutor二级缓存执行器，不太明白的话可以看上面已经讲清楚了为什么是这个执行器。  </li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <E> <span class="function">List<E> <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>BoundSql保存了sql语句。</li><li>CacheKey缓存的key，里面通过一级缓存创建，然后又因为一级缓存没有这个方法走的是父类BaseExecutor。  </li><li>生成的key:2146019561:4003012542:com.animo.mybatis.source.mapper.UserMapper.getById:0:2147483647:select * from <code>user</code> where id = ?:17:development2  </li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <E> <span class="function">List<E> <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) {</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() && resultHandler == <span class="keyword">null</span>) {</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        List<E> list = (List<E>) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) {</span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>Cache cache = ms.getCache();这是二级缓存需要实现的接口，这边没有自定义二级缓存所以为空。  </li><li>二级缓存没设置的话，走了一级缓存的query查询方法。</li><li>这里的执行器采用了模板方法设计模式，公共方法抽象类实现，子类实现不同方法，子类还可以重写相同方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <E> <span class="function">List<E> <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> && ms.isFlushCacheRequired()) {</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    }</span><br><span class="line">    List<E> list;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List<E>) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) {</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      queryStack--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) {</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>PerpetualCache localCache 内部使用HashMap进行一级缓存，在该方法第一次查询的时候是不存在缓存中所以走数据库。  </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <E> <span class="function">List<E> <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">   List<E> list;</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">     localCache.removeObject(key);</span><br><span class="line">   }</span><br><span class="line">   localCache.putObject(key, list);</span><br><span class="line">   <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) {</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ol><li>localCache.putObject(key, EXECUTION_PLACEHOLDER);占位符作用</li><li>把查询好的结果缓存到HashMap中。</li><li>内部查询使用了PreparedStatementHandler预处理器。</li></ol><h1 id="一级缓存和二级缓存的区别"><a href="#一级缓存和二级缓存的区别" class="headerlink" title="一级缓存和二级缓存的区别"></a>一级缓存和二级缓存的区别</h1><ol><li>一级缓存使用HashMap进行存储。</li><li>一级缓存作用于同一个SqlSession。</li><li>二级缓存作用于在同一个namespace。</li><li>二级缓存可以使用第三方缓存框架。</li></ol><h1 id="一级缓存存在什么问题"><a href="#一级缓存存在什么问题" class="headerlink" title="一级缓存存在什么问题"></a>一级缓存存在什么问题</h1><p>一级缓存存储数据在本地内存中，在集群情况下容易引发脏数据，举个栗子有两台集群机器（A、B）。<br>客户端在A中查询了一条记录，然后客户端在B中更新了A查询的记录，由于Mybatis清空缓存的条件是DML（增删改）操作，就会清空hashmap中缓存的所有数据。<br>所以A并不知情就出现了脏数据。</p><h1 id="如何清空一级缓存"><a href="#如何清空一级缓存" class="headerlink" title="如何清空一级缓存"></a>如何清空一级缓存</h1><ol><li>SQL传入随机数 #{random} = #{random}。</li><li>执行DML操作。</li><li>调用SqlSession中的clearCache()方法。</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码分析之多数据源(environment)</title>
      <link href="/1345018663.html"/>
      <url>/1345018663.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Mybatis执行顺序、Mybatis源码分析、MyBatis SqlSessionFactoryBuilder、Mybatis多数据源切换、Mybatis一级缓存问题、Mybatis二级缓存如何使用。  </p></blockquote><h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><h2 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.12&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="MyBatis配置"><a href="#MyBatis配置" class="headerlink" title="MyBatis配置"></a>MyBatis配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;settings&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;development1&quot;&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;development1&quot;&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;development2&quot;&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class UserEntity &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    UserEntity getById(Integer id);</span><br><span class="line">    int insert(UserEntity userEntity);</span><br><span class="line">&#125;</span><br><span class="line">CREATE TABLE &#96;mybatis_resource&#96;.&#96;无标题&#96;  (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 7 CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br></pre></td></tr></table></figure><h1 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h1><blockquote><p>使用MyBatis自带的Resource工具类是可以自动定位项目中resource文件夹下的文件。<br>默认的openSession方法是不会自动提交事物的只适合查询，如果需要自动提交事物可以加个入参true;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String resource &#x3D;  &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    try (SqlSession sqlSession &#x3D; sqlSessionFactory.openSession())&#123;</span><br><span class="line">        UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        System.out.println(userMapper.getById(1).toString());</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>new SqlSessionFactoryBuilder().build(inputStream)<br>从SqlSessionFactory到XMLConfigBuilder，environment参数后面会提到，这里的parser.parse()方法主要就是解析Mybatis配置文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>入参是configuration节点的内容，由于分析数据源所以我们需要看environmentsElement(root.evalNode(“environments”))方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在if (environment == null) 判断当中environment就是上面初始化XMLConfigBuilder提到的参数，这个其实就是指定数据源的id。<br>如果没有指定的话就会查找environments节点默认的（default）id。<br>在 isSpecifiedEnvironment(id)这个方法中，如果当前子节点的id也就是循环的数据源的id，与默认id不相等的话是不会被设置。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context !&#x3D; null) &#123;</span><br><span class="line">      if (environment &#x3D;&#x3D; null) &#123;</span><br><span class="line">        environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      for (XNode child : context.getChildren()) &#123;</span><br><span class="line">        String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">        if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">          TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">          DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">          DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line">          Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">              .transactionFactory(txFactory)</span><br><span class="line">              .dataSource(dataSource);</span><br><span class="line">          configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Environment类中就是配置了单个节点的数据源信息。<br>configuration.setEnvironment()方法只会设置一个，所以如果多个数据源的id与default一致的话那么就会被顺序替换，也就是说最后一个数据源会被使用。<br>Configuration在初始化XMLConfigBuilder的时候就被初始化了是装配整个xml的配置信息。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Environment属性</span><br><span class="line">private final String id; # 数据源ID</span><br><span class="line">private final TransactionFactory transactionFactory; # 事物</span><br><span class="line">private final DataSource dataSource; # 数据源</span><br></pre></td></tr></table></figure><blockquote><p>首先我们知道了整个Mybatis的执行流程代码，在new SqlSessionFactoryBuilder().build(inputStream)中有三个参数可以选择，第一个是配置文件流这是必须的，第二个是指定读取哪个数据源，第三个是配置文件。<br>所以我们可以根据传入第二个参数来指定使用数据源，在写之前我们先了解这几个类作用域和生命周期。  </p></blockquote><h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><blockquote><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。  </p></blockquote><p>我们的做法就可以使用内存在缓存起来这样可以保证数据源ID对应一个SqlSessionFactory。  </p><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><blockquote><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。  </p></blockquote><p>说白了就是一次请求对应一次开启和关闭也就是作用域在方法中。  </p><h2 id="数据源动态获取"><a href="#数据源动态获取" class="headerlink" title="数据源动态获取"></a>数据源动态获取</h2><blockquote><p>其实对于SqlSessionFactory的话可以在项目启动的时候就初始化，这样的话在使用的时候效率会比较高。<br>封装方面可以更加灵活这里只是做了个简单的demo。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SqlSessionUtils &#123;</span><br><span class="line">    private final static String resource &#x3D;  &quot;mybatis-config.xml&quot;;</span><br><span class="line">    private static InputStream inputStream;</span><br><span class="line">    private static Map&lt;String,SqlSessionFactory&gt; stringSqlSessionMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static SqlSessionFactory getSqlSessionFactory(String environment)&#123;</span><br><span class="line">        if(stringSqlSessionMap.containsKey(environment))&#123;</span><br><span class="line">           return stringSqlSessionMap.get(environment);</span><br><span class="line">        &#125;</span><br><span class="line">        InputStream inputStream &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream,environment);</span><br><span class="line">            stringSqlSessionMap.put(environment,sqlSessionFactory);</span><br><span class="line">            return sqlSessionFactory;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public static SqlSession openSqlSession(String environment)&#123;</span><br><span class="line">        SqlSession sqlSession &#x3D; getSqlSessionFactory(environment).openSession(true);</span><br><span class="line">        return sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>在使用层面的话，上面说了SqlSession的作用域，所以可以使用1.8写法把创建放在try()中，这个就无须关心资源的关闭。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (SqlSession sqlSession &#x3D; SqlSessionUtils.openSqlSession(&quot;development2&quot;)) &#123;</span><br><span class="line">    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/378231173.html"/>
      <url>/378231173.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>当对象存在一对多关系的时候就可以考虑用观察者模式，例如：微信公众号发送文章、用户下单各种通知。  </p></blockquote><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li>抽象观察者(ObServer)</li><li>抽象主题（Subject、被观察者、ObServable）</li><li>具体观察者 （多个）</li><li>具体抽象主题（对应多个观察者）</li></ul><h1 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h1><blockquote><p>通过微信公众号发送文章通知到订阅者例子。</p></blockquote><h2 id="抽象观察者"><a href="#抽象观察者" class="headerlink" title="抽象观察者"></a>抽象观察者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface  ExtObServer &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 主要方法</span><br><span class="line">    void update(Object message);</span><br><span class="line"></span><br><span class="line">    String getName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserObServerImpl implements ExtObServer &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public UserObServerImpl(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(Object message) &#123;</span><br><span class="line">        System.out.println(name + &quot;接收文章:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主题（被观察者）"><a href="#主题（被观察者）" class="headerlink" title="主题（被观察者）"></a>主题（被观察者）</h2><blockquote><p>这里就不写抽象主题了，主要包含添加观察者、移除观察者、通知所有观察者。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ExtSubject &#123;</span><br><span class="line">    private List&lt;ExtObServer&gt; list;</span><br><span class="line">    public ExtSubject ()&#123;</span><br><span class="line">        list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public void addObserver(ExtObServer obServer)&#123;</span><br><span class="line">        if(!list.contains(obServer))&#123;</span><br><span class="line">            list.add(obServer);</span><br><span class="line">            System.out.println(&quot;恭喜&quot; + obServer.getName() + &quot;同学订阅成功;微信公众号:悸动的骚年！！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void removeObServer(ExtObServer obServer)&#123;</span><br><span class="line">        list.remove(obServer);</span><br><span class="line">        System.out.println(obServer.getName() + &quot;取消订阅！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyAllObServer(Object message)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); ++i) &#123;</span><br><span class="line">            list.get(i).update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ExtSubject extSubject &#x3D; new ExtSubject();</span><br><span class="line">    extSubject.addObserver(new UserObServerImpl(&quot;小明&quot;));</span><br><span class="line">    extSubject.addObserver(new UserObServerImpl(&quot;小红&quot;));</span><br><span class="line">    extSubject.addObserver(new UserObServerImpl(&quot;小光&quot;));</span><br><span class="line">    extSubject.addObserver(new UserObServerImpl(&quot;小刚&quot;));</span><br><span class="line"></span><br><span class="line">    extSubject.notifyAllObServer(&quot;SpringBoot集成MyBatisPlus&quot;);</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">恭喜小明同学订阅成功;微信公众号:悸动的骚年！！！</span><br><span class="line">恭喜小红同学订阅成功;微信公众号:悸动的骚年！！！</span><br><span class="line">恭喜小光同学订阅成功;微信公众号:悸动的骚年！！！</span><br><span class="line">恭喜小刚同学订阅成功;微信公众号:悸动的骚年！！！</span><br><span class="line">小明接收文章:SpringBoot集成MyBatisPlus</span><br><span class="line">小红接收文章:SpringBoot集成MyBatisPlus</span><br><span class="line">小光接收文章:SpringBoot集成MyBatisPlus</span><br><span class="line">小刚接收文章:SpringBoot集成MyBatisPlus</span><br></pre></td></tr></table></figure><h1 id="基于JDK实现"><a href="#基于JDK实现" class="headerlink" title="基于JDK实现"></a>基于JDK实现</h1><blockquote><p>ObServer代表抽象观察者、Observable代表主题。  </p></blockquote><h2 id="具体观察者-1"><a href="#具体观察者-1" class="headerlink" title="具体观察者"></a>具体观察者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class UserObserver implements Observer &#123;</span><br><span class="line">    private String userName;</span><br><span class="line">    public UserObserver(String userName) &#123;</span><br><span class="line">        this.userName &#x3D; userName;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param observable 被观察者 也就是主题 需要订阅的</span><br><span class="line">     * @param arg</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable observable, Object arg) &#123;</span><br><span class="line">        System.out.println(&quot;接受者：&quot; + userName + &quot;;接收的消息：&quot; + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体主题"><a href="#具体主题" class="headerlink" title="具体主题"></a>具体主题</h2><blockquote><p>这边的话继承JDK自带的主题，然后构造方法中使用的是父类的方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class WechatObservable extends Observable &#123;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        notifyObservers(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WechatObservable() &#123;</span><br><span class="line">        setChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在调用父类的notifyObservers方法，内部有个changed默认是false的，源代码中如果changed为false是无法通知观察者的所以需要设置为true，但是发送了一次之后这个值又会被重新设置为false这个需要注意。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void notifyObservers(Object arg) &#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; false直接return，true的话不进if，然后把changed变成false</span><br><span class="line">            if (!changed)</span><br><span class="line">                return;</span><br><span class="line">            arrLocal &#x3D; obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; arrLocal.length-1; i&gt;&#x3D;0; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(this, arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><blockquote><p>这边如果需要循环发送的话，需要在setMessage方法中调用setChanged()，让他在通知之前改变changed的值才可以通知到全部观察者。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    WechatObservable wechatObservable &#x3D; new WechatObservable();</span><br><span class="line"></span><br><span class="line">    wechatObservable.addObserver(new UserObserver(&quot;小明1&quot;));</span><br><span class="line">    wechatObservable.addObserver(new UserObserver(&quot;小明2&quot;));</span><br><span class="line">    wechatObservable.addObserver(new UserObserver(&quot;小明3&quot;));</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10 ; i++) &#123;</span><br><span class="line">        wechatObservable.setMessage(&quot;嘿嘿嘿&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于spring实现"><a href="#基于spring实现" class="headerlink" title="基于spring实现"></a>基于spring实现</h1><blockquote><p>在spring中也提供了观察者，主要有这几个类实现。  </p></blockquote><ul><li>ApplicationEvent （事件）主要用于定义发送的事件类型</li><li>ApplicationListener&lt;?&gt;（观察者）泛型是传入事件参数<h2 id="抽象事件"><a href="#抽象事件" class="headerlink" title="抽象事件"></a>抽象事件</h2><blockquote><p>我们定义了一个JSONObject的事件类型，其实这里也不需要改动只需要继承ApplicationEvent即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class JsonObjectEvent extends ApplicationEvent &#123;</span><br><span class="line">    public JsonObjectEvent(JSONObject source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        System.out.println(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者（监听）"><a href="#观察者（监听）" class="headerlink" title="观察者（监听）"></a>观察者（监听）</h2><blockquote><p>event.getSource()就可以得到通知过来的事件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class JsonListener1 implements ApplicationListener&lt;JsonObjectEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(JsonObjectEvent event) &#123;</span><br><span class="line">        System.out.println(event.getSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">public class JsonListener2 implements ApplicationListener&lt;JsonObjectEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(JsonObjectEvent event) &#123;</span><br><span class="line">        System.out.println(event.getSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><blockquote><p>在spring中相比于原来少了主题的概念，主要是spring内部自己维护，我们只需要把观察者注入到容器中即可，然后spring通过反射机制就可以知道需要通知哪些事件类型的观察者。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于发送事件通知</span><br><span class="line">@Component</span><br><span class="line">public class Publish implements ApplicationContextAware &#123;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    public void publishEvent(Object event)&#123;</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; publishEvent中需要传入写好的事件类型，不然的话通知不到。</span><br><span class="line">@RestController</span><br><span class="line">public class EventController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public Publish publish;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;event&quot;)</span><br><span class="line">    public String event()&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(16);</span><br><span class="line">        map.put(&quot;11&quot;,&quot;11&quot;);</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject(map);</span><br><span class="line">        JsonObjectEvent jsonObjectEvent &#x3D; new JsonObjectEvent(jsonObject);</span><br><span class="line">        publish.publishEvent(jsonObjectEvent);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JDK动态代理</title>
      <link href="/2588153571.html"/>
      <url>/2588153571.html</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>通过接口来获取方法和参数。</li><li>组装代理类java代码模板。</li><li>通过JavaCompiler（javac）进行java代码编译。</li><li>通过自定义CLassLoader加载编译好的源代码到内存中。</li></ul><h1 id="自定义InvocationHandler接口"><a href="#自定义InvocationHandler接口" class="headerlink" title="自定义InvocationHandler接口"></a>自定义InvocationHandler接口</h1><blockquote><p>这里与JDK自己的InvocationHandler一致。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface ExtInvocationHandler &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param proxy 代理类</span><br><span class="line">     * @param method 方法</span><br><span class="line">     * @param args 方法参数</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试的接口"><a href="#测试的接口" class="headerlink" title="测试的接口"></a>测试的接口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderService &#123;</span><br><span class="line">    void service();</span><br><span class="line">&#125;</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void service() &#123;</span><br><span class="line">        System.out.println(&quot;执行订单业务逻辑-----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h1><blockquote><p>这边与JDK动态代理实现代码一致，主要区别在于getProxyCLass方法，使用自定义的代理类来获取代理对象，与原来对比少了个类加载器，这里使用的是我们自定义的所以不需要当做参数传递。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class InvocationImpl implements ExtInvocationHandler &#123;</span><br><span class="line">    private Object target;</span><br><span class="line">    public InvocationImpl(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;自定义JDK动态代理类：&quot; + proxy);</span><br><span class="line">        System.out.println(&quot;自定义JDK代理开始&quot;);</span><br><span class="line">        Object result &#x3D; method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;自定义JDK代理结束&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getProxyCLass()&#123;</span><br><span class="line">        return ExtProxy.newProxyInstance(target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ExtProxy"><a href="#ExtProxy" class="headerlink" title="ExtProxy"></a>ExtProxy</h1><blockquote><p>代理类代码比较简单，构造与之前一样也是需要传递一个拦截器实现，newProxyInstance方法获取class类，然后通过构造获取动态代理生成的类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ExtProxy &#123;</span><br><span class="line">    public ExtInvocationHandler h;</span><br><span class="line">    public ExtProxy()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public ExtProxy(ExtInvocationHandler h) &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        this.h &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Object newProxyInstance(Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          ExtInvocationHandler h)</span><br><span class="line">            throws IllegalArgumentException &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 检查拦截器</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取动态代理类</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; CreateClass.getClass(interfaces);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取有参构造</span><br><span class="line">            Constructor constructor &#x3D; clazz.getDeclaredConstructor(ExtInvocationHandler.class);</span><br><span class="line">            &#x2F;&#x2F; 实例化代理类</span><br><span class="line">            return constructor.newInstance(h);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组装代理类Java代码"><a href="#组装代理类Java代码" class="headerlink" title="组装代理类Java代码"></a>组装代理类Java代码</h1><blockquote><p>首先可以把原先JDK动态代理的生成的代理类文件拿出来分析，看看哪些是动态的，在进行StringBuilder封装。<br>由于class源代码与java代码有些不一样，可以自己手动写个代理类来测试，这里就不过多演示，直接把模板贴出。<br>下面代码是已经格式化了的模板，把equals、toString、hashCode、静态代码块都删除了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.animo.auto;</span><br><span class="line">import com.animo.auto.proxy.ext.ExtInvocationHandler;</span><br><span class="line">import com.animo.auto.proxy.ext.ExtProxy;</span><br><span class="line">import com.animo.auto.proxy.ext.test.OrderService;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends ExtProxy implements OrderService &#123;</span><br><span class="line">    public $Proxy0(ExtInvocationHandler var1) &#123;</span><br><span class="line">            super(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void service()&#123; </span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, Class.forName(&quot;com.animo.auto.proxy.ext.test.OrderService&quot;).getMethod(&quot;service&quot;), (Object[])null);</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们都知道JDK动态代理生成的代理类文件名是$Proxy0/1/2/3/4，后面的数字都是递增的，在防止高并发情况下，使用原子类自增即可。<br>实现接口，接口类名是动态（interface1,interface2）可以多重实现，其次就是接口导包import也是跟随接口动态。<br>构造方法中方法名称跟随类名称也是动态的。<br>其次就是方法了，这些方法都是接口中需要实现的，方法名和方法参数是动态，还有就是invoke中第二个和第三个参数，分别是通过反射获取Method和传入方法的参数。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Parameter;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">public class CreateClass &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 用于控制代理类名称序号</span><br><span class="line">    private static AtomicInteger  atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    private static final String PACKGE &#x3D; &quot;package com.animo.auto;\n&quot;;</span><br><span class="line"></span><br><span class="line">    private static final String importS &#x3D; &quot;import com.animo.auto.proxy.ext.ExtInvocationHandler;\n&quot;+</span><br><span class="line">            &quot;import com.animo.auto.proxy.ext.ExtProxy;\n&quot;;</span><br><span class="line"></span><br><span class="line">    private static String className &#x3D; &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">    private static String publicClass &#x3D; &quot;\npublic final class %s extends ExtProxy implements %s &#123;\n\n&quot;;</span><br><span class="line"></span><br><span class="line">    private static String constructor &#x3D; &quot;public %s(ExtInvocationHandler var1) &#123;\n&quot; +</span><br><span class="line">            &quot;        super(var1);\n&quot; +</span><br><span class="line">            &quot;    &#125;\n&quot;;</span><br><span class="line"></span><br><span class="line">    private CreateClass() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Class&lt;?&gt; getClass(Class&lt;?&gt;[] interfaces)&#123;</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 从包和导包开始封装</span><br><span class="line">        stringBuilder.append(PACKGE).append(importS);</span><br><span class="line">        int interfacesLength &#x3D; interfaces.length;</span><br><span class="line">        String interfaceS &#x3D; &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F; 循环多个接口拼接import和实现接口</span><br><span class="line">        for (int i &#x3D; 0; i &lt; interfacesLength; i++) &#123;</span><br><span class="line">            stringBuilder.append(&quot;import &quot; + interfaces[i].getName() + &quot;;\n&quot;);</span><br><span class="line">            interfaceS +&#x3D; interfaces[i].getSimpleName();</span><br><span class="line">            if(i!&#x3D;interfaces.length-1)&#123;</span><br><span class="line">                interfaceS+&#x3D;&quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 组装类名</span><br><span class="line">        String classNameTemp &#x3D; className + atomicInteger.getAndIncrement();</span><br><span class="line">        &#x2F;&#x2F; 格式化类头代码 把 实现类替换</span><br><span class="line">        stringBuilder.append(String.format(publicClass,classNameTemp,interfaceS));</span><br><span class="line">        &#x2F;&#x2F; 格式化构造方法 把 方法名替换</span><br><span class="line">        stringBuilder.append(String.format(constructor,classNameTemp));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;遍历所有实现的接口的方法</span><br><span class="line">        stringBuilder.append(getMethod(interfaces));</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 类的合并结尾括号</span><br><span class="line">        stringBuilder.append(&quot;\n&#125;&quot;);</span><br><span class="line">   </span><br><span class="line">        &#x2F;&#x2F; 存储java代理类代码路径。</span><br><span class="line">        String pathName &#x3D; &quot;&#x2F;Users&#x2F;liujinyong&#x2F;Desktop&#x2F;auto&#x2F;&quot; + classNameTemp + &quot;.java&quot;;</span><br><span class="line"></span><br><span class="line">        FileWriter fileWriter &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            File file &#x3D; new File(pathName);</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            fileWriter &#x3D; new FileWriter(file);</span><br><span class="line">            fileWriter.write(stringBuilder.toString());</span><br><span class="line">            fileWriter.flush();</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 上面已经把代理类写到了指定路径中，然后通过javac编译，编译之后的源代码在传入的路径下。</span><br><span class="line">        JavaCompilerUtils.compile(pathName);</span><br><span class="line">        ExtClassLoader classLoader &#x3D; new ExtClassLoader();</span><br><span class="line">        &#x2F;&#x2F; 通过自定义的ClassLoader把源代码加载到内存中</span><br><span class="line">        return classLoader.findClass(classNameTemp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static StringBuilder getMethod(Class&lt;?&gt;[] interfaces)&#123;</span><br><span class="line">        StringBuilder methodS &#x3D; new StringBuilder();</span><br><span class="line">        for (int a &#x3D; 0; a &lt; interfaces.length; a++) &#123;</span><br><span class="line">            StringBuilder stringBuilder &#x3D; new StringBuilder(&quot;Class.forName(\&quot;&quot;);</span><br><span class="line">            stringBuilder.append(interfaces[a].getName());</span><br><span class="line">            stringBuilder.append(&quot;\&quot;).getMethod(\&quot;&quot;);</span><br><span class="line">            Method[] methods &#x3D; interfaces[a].getMethods();</span><br><span class="line">            for(Method method : methods)&#123;</span><br><span class="line">                String s &#x3D; method.getName();</span><br><span class="line">                String aaa &#x3D; method.getName() + &quot;(&quot;;</span><br><span class="line">                Parameter[] parameters &#x3D; method.getParameters();</span><br><span class="line">                String objects &#x3D; &quot;(Object[])null&quot;;</span><br><span class="line">                if(parameters.length &gt; 0)&#123;</span><br><span class="line">                    objects &#x3D; &quot;new Object[]&#123;null&#125;&quot;;</span><br><span class="line">                    s +&#x3D; &quot;\&quot;,&quot;;</span><br><span class="line">                    String objectsd &#x3D; &quot;&quot;;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt;parameters.length ; i++) &#123;</span><br><span class="line">                        objectsd +&#x3D; parameters[i].getName();</span><br><span class="line">                        s +&#x3D; &quot;Class.forName(\&quot;&quot;+parameters[i].getParameterizedType().getTypeName()+&quot;\&quot;)&quot;;</span><br><span class="line">                        aaa +&#x3D; parameters[i].getParameterizedType().getTypeName() +&quot; &quot; + parameters[i].getName();</span><br><span class="line">                        if(i !&#x3D; parameters.length - 1)&#123;</span><br><span class="line">                            aaa +&#x3D; &quot;,&quot;;</span><br><span class="line">                            objectsd +&#x3D; &quot;,&quot;;</span><br><span class="line">                            s +&#x3D; &quot;,&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    objects &#x3D; objects.replace(&quot;null&quot;,objectsd);</span><br><span class="line">                    aaa +&#x3D; &quot;)&quot;;</span><br><span class="line">                    s +&#x3D;&quot;)&quot;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    aaa +&#x3D; &quot;)&quot;;</span><br><span class="line">                    s +&#x3D; &quot;\&quot;)&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder stringBuilder1 &#x3D; createMethod(aaa,stringBuilder.toString() + s,objects);</span><br><span class="line">                methodS.append(stringBuilder1).append(&quot;\n\n\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return methodS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static StringBuilder createMethod(String method,String methodCLass,String object)&#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder(&quot;@Override\npublic final void &quot;);</span><br><span class="line">        &#x2F;&#x2F; 动态变化</span><br><span class="line">        stringBuilder.append(method);</span><br><span class="line">        stringBuilder.append(&quot;&#123; \ntry &#123;\n&quot;);</span><br><span class="line">        &#x2F;&#x2F; 动态变化</span><br><span class="line">        stringBuilder.append(&quot;super.h.invoke(this, &quot;+methodCLass+&quot;, &quot;+object+&quot;);&quot;);</span><br><span class="line">        stringBuilder.append(&quot;\n&#125; catch (Throwable throwable) &#123;\n&quot; +</span><br><span class="line">                &quot;            throwable.printStackTrace();\n&quot; +</span><br><span class="line">                &quot;        &#125;\n&#125;&quot;);</span><br><span class="line">       return stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类编译"><a href="#类编译" class="headerlink" title="类编译"></a>类编译</h1><blockquote><p>这一段算是死代码，只需要传入对应的java类路径即可编译。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class JavaCompilerUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static void compile(String fileName)&#123;</span><br><span class="line">        JavaCompiler compiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileMgr &#x3D; compiler.getStandardFileManager(null,null,null);</span><br><span class="line">        Iterable units &#x3D; fileMgr.getJavaFileObjects(fileName);</span><br><span class="line">        JavaCompiler.CompilationTask t &#x3D; compiler.getTask(null,null,null,null,null,units);</span><br><span class="line">        t.call();</span><br><span class="line">        try &#123;</span><br><span class="line">            fileMgr.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><blockquote><p>通过继承ClassLoader实现我们自己的类加载器，这边路径可以选择全路径也可以是指定路径。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ExtClassLoader extends ClassLoader&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path &#x3D; &quot;&#x2F;Users&#x2F;liujinyong&#x2F;Desktop&#x2F;mykt&#x2F;&quot; + name + &quot;.class&quot; ;</span><br><span class="line">            FileInputStream in &#x3D; new FileInputStream(path) ;</span><br><span class="line">            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream() ;</span><br><span class="line">            byte[] buf &#x3D; new byte[1024] ;</span><br><span class="line">            int len &#x3D; -1 ;</span><br><span class="line">            while((len &#x3D; in.read(buf)) !&#x3D; -1)&#123;</span><br><span class="line">                baos.write(buf , 0 , len);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            byte[] classBytes &#x3D; baos.toByteArray();</span><br><span class="line">            return defineClass(classBytes , 0 , classBytes.length) ;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用的话与JDK动态代理一致，只要实现了接口的实现类都可以代理。<br>其实手写的话主要在于组装代理类模板，其余的都算是死代码只需要封装成工具类就好了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之代理模式</title>
      <link href="/2423943376.html"/>
      <url>/2423943376.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。<br>代理模式实现分别为接口和继承。 </p></blockquote><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li>抽象角色<br>通过接口或抽象类声明真实角色实现的业务方法。 </li><li>代理角色<br>实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作增强真实角色。  </li><li>真实角色<br>实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</li></ul><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><blockquote><p>静态代理就是我们通过自己手动实现的代理类在java代码中已经硬编码编写好了。  </p></blockquote><p><img alt data-src="/img/sjms/dlms.png" class="lozad">  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="抽象角色"><a href="#抽象角色" class="headerlink" title="抽象角色"></a>抽象角色</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface StaticInterface {</span><br><span class="line">    // 执行SQL业务逻辑 模拟代码---</span><br><span class="line">    void service(String param);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTarget implements StaticInterface {</span><br><span class="line">    @Override</span><br><span class="line">    public void service(String param) {</span><br><span class="line">        System.out.println("参数:" + param + ",执行SQL开始");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy implements StaticInterface {</span><br><span class="line">    // 目标对象</span><br><span class="line">    private StaticInterface staticInterface;</span><br><span class="line">    public StaticProxy(StaticInterface staticInterface) {</span><br><span class="line">        this.staticInterface = staticInterface;</span><br><span class="line">    }</span><br><span class="line">    @Override</span><br><span class="line">    public void service(String param) {</span><br><span class="line">        System.out.println("事物开启！");</span><br><span class="line">        staticInterface.service(param);</span><br><span class="line">        System.out.println("事物提交！");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StaticProxy staticProxy = new StaticProxy(new StaticTarget());</span><br><span class="line">staticProxy.service("实现");</span><br></pre></td></tr></tbody></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承的话相对上面的代码不需要抽象角色，代理角色直接继承真实角色。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 真实角色</span><br><span class="line">public class StaticTarget{</span><br><span class="line">    public void service(String param) {</span><br><span class="line">        System.out.println("参数:" + param + ",执行SQL开始");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// 代理角色</span><br><span class="line">public class StaticProxyExtends extends StaticTarget {</span><br><span class="line">    @Override</span><br><span class="line">    public void service(String param) {</span><br><span class="line">        System.out.println("事物开启！");</span><br><span class="line">        // super 代表 StaticTarget</span><br><span class="line">        super.service(param);</span><br><span class="line">        System.out.println("事物提交！");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// 测试</span><br><span class="line">StaticProxyExtends staticProxyExtends = new StaticProxyExtends();</span><br><span class="line">staticProxyExtends.service("继承");</span><br></pre></td></tr></tbody></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><blockquote><p>JDK动态代理基于接口通过反射实现。  </p></blockquote><h3 id="抽象角色-1"><a href="#抽象角色-1" class="headerlink" title="抽象角色"></a>抽象角色</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface JdkInterface {</span><br><span class="line">    void service(String param);</span><br><span class="line">    void getList();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="真实角色-1"><a href="#真实角色-1" class="headerlink" title="真实角色"></a>真实角色</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class JdkTarget implements JdkInterface {</span><br><span class="line">    @Override</span><br><span class="line">    public void service(String param) {</span><br><span class="line">        System.out.println("参数:" + param + ",执行SQL开始");</span><br><span class="line">    }</span><br><span class="line">    @Override</span><br><span class="line">    public void getList() {</span><br><span class="line">        System.out.println("执行查询*SQL开始");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JdkInvocation implements InvocationHandler {</span><br><span class="line">    // 需要被代理的对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public JdkInvocation(Object target) {</span><br><span class="line">        this.target = target;</span><br><span class="line">    }</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span><br><span class="line">        System.out.println("事物开启！");</span><br><span class="line">        System.out.println("Method:" + method);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println("result:" + result);</span><br><span class="line">        System.out.println("事物提交！");</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public Object getProxyClass() {</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 把代理对象输出到当前项目中</span><br><span class="line">System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");</span><br><span class="line">// 获取代理类</span><br><span class="line">JdkInterface jdkInterface = (JdkInterface) new JdkInvocation(new JdkTarget()).getProxyClass();</span><br><span class="line">jdkInterface.service("JDK动态代理");</span><br></pre></td></tr></tbody></table></figure><blockquote><p>我们主要从getProxyClass分析开始。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里的target指的是JdkTarget、this就是当前的InvocationHandler对象</span><br><span class="line">Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以下是newProxyInstance源代码。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class<?>[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    {</span><br><span class="line">        // 检查拦截器是否为空</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        </span><br><span class="line">        final Class<?>[] intfs = interfaces.clone();</span><br><span class="line">        final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) {</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 生成代理类</span><br><span class="line">        Class<?> cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            if (sm != null) {</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            }</span><br><span class="line">            // 调用代理类的构造函数传入指定参数constructorParams = InvocationHandler.class</span><br><span class="line">            final Constructor<?> cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) {</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction<Void>() {</span><br><span class="line">                    public Void run() {</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">            // 反射生成对象，传入的参数就是我们的InvocationHandler实现类，最终返回动态生成的代理对象，用抽象角色接收。</span><br><span class="line">            return cons.newInstance(new Object[]{h});</span><br><span class="line">        } catch (IllegalAccessException|InstantiationException e) {</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        } catch (InvocationTargetException e) {</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) {</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            } else {</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            }</span><br><span class="line">        } catch (NoSuchMethodException e) {</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以下是生成的代理类的字节码。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 代理类继承了Proxy然后实现了抽象角色，在上面代码中返回的是动态代理类，所以使用接口接收。</span><br><span class="line">public final class $Proxy0 extends Proxy implements JdkInterface {</span><br><span class="line">    // m3、m4都是我们抽象角色中需要实现的方法。 省略了equals、toString、hashCode</span><br><span class="line">    static {</span><br><span class="line">        try {</span><br><span class="line">            m3 = Class.forName("com.animo.mykt.proxy.jdk.JdkInterface").getMethod("getList");</span><br><span class="line">            m4 = Class.forName("com.animo.mykt.proxy.jdk.JdkInterface").getMethod("service", Class.forName("java.lang.String"));</span><br><span class="line">        } catch (NoSuchMethodException var2) {</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        } catch (ClassNotFoundException var3) {</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    </span><br><span class="line">    // 这个var1是在Proxy.newProxyInstance()方法中传入的也就是我们的JdkInvocation</span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  {</span><br><span class="line">        // 这里调用了Proxy类有参构造把我们的JdkInvocation赋值给了全局变量protected InvocationHandler h;</span><br><span class="line">        super(var1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public final void service(String var1) throws  {</span><br><span class="line">        try {</span><br><span class="line">            // 这里的super.h就是代表JdkInvocation，然后通过反射调用方法，所以结合代理类在看我们的JdkInvocation就很好理解。</span><br><span class="line">            super.h.invoke(this, m4, new Object[]{var1});</span><br><span class="line">        } catch (RuntimeException | Error var3) {</span><br><span class="line">            throw var3;</span><br><span class="line">        } catch (Throwable var4) {</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public final void getList() throws  {</span><br><span class="line">        try {</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        } catch (RuntimeException | Error var2) {</span><br><span class="line">            throw var2;</span><br><span class="line">        } catch (Throwable var3) {</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><h3 id="真实角色-2"><a href="#真实角色-2" class="headerlink" title="真实角色"></a>真实角色</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CglibTarget {</span><br><span class="line"></span><br><span class="line">    public void service(String param) {</span><br><span class="line">        System.out.println("参数:" + param + ",执行SQL开始");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void getList() {</span><br><span class="line">        System.out.println("执行查询*SQL开始");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拦截器-1"><a href="#拦截器-1" class="headerlink" title="拦截器"></a>拦截器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CglibInterceptor implements MethodInterceptor {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object target, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {</span><br><span class="line">        System.out.println("事物开启！");</span><br><span class="line">        Object result = methodProxy.invokeSuper(target,args);</span><br><span class="line">        System.out.println("事物结束！");</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getProxyClass(Object target){</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/Desktop/");</span><br><span class="line">CglibTarget cglibTarget = (CglibTarget) new CglibInterceptor().getProxyClass(new CglibTarget());</span><br><span class="line">cglibTarget.getList();</span><br><span class="line">cglibTarget.service("Cglib动态代理");</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/441148158.html"/>
      <url>/441148158.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>保证单个JVM当中一个类只有一个实例，并提供一个访问它的全局访问点。  </p></blockquote><h1 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h1><blockquote><p>懒汉式单例在需要使用时才被实例化且只被实例化一次。<br>优点：需要使用才被调用，避免内存浪费。<br>缺点：线程安全问题，并发情况容易导致多个实例对象。   </p></blockquote><h1 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h1><blockquote><p>饿汉式单例类加载时就初始化，天生线程安全。<br>优点：天生线程安全。<br>缺点：内存浪费、影响启动速度。  </p></blockquote><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton {</span><br><span class="line">    private static HungrySingleton hungrySingleton = new HungrySingleton();</span><br><span class="line">    private HungrySingleton(){}</span><br><span class="line">    public static HungrySingleton getInstance(){</span><br><span class="line">        return hungrySingleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton {</span><br><span class="line">    private static LazySingleton lazySingleton;</span><br><span class="line">    private LazySingleton(){}</span><br><span class="line">    public static LazySingleton getInstance(){</span><br><span class="line">        if(lazySingleton == null){</span><br><span class="line">            lazySingleton = new LazySingleton();</span><br><span class="line">        }</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h1><blockquote><p>第一次判断中如果无法过滤只能一个线程进入，就会导致多个线程进入if判断，里面没有第二层判断的话就会导致实例化多个对象。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LazySecuritySingleton {</span><br><span class="line">    private static LazySecuritySingleton lazySecuritySingleton;</span><br><span class="line">    private LazySecuritySingleton() {}</span><br><span class="line">    public static LazySecuritySingleton getInstance(){</span><br><span class="line">        if(lazySecuritySingleton == null){</span><br><span class="line">            synchronized (LazySecuritySingleton.class){</span><br><span class="line">                if(lazySecuritySingleton == null){</span><br><span class="line">                    lazySecuritySingleton = new LazySecuritySingleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return lazySecuritySingleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><blockquote><p>相对于普通饿汉式来说在外部类加载的时候不会被初始化，然后只有调用了内部类的getInstance()方法才会初始化，避免内存占用。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ClassSingleton {</span><br><span class="line">    private ClassSingleton(){</span><br><span class="line">        System.out.println("初始化");</span><br><span class="line">    }</span><br><span class="line">    public static class ClassSingletonUtils{</span><br><span class="line">    </span><br><span class="line">        private static ClassSingleton classSingleton = new ClassSingleton();</span><br><span class="line"></span><br><span class="line">        public static ClassSingleton getInstance(){</span><br><span class="line">            System.out.println("使用");</span><br><span class="line">            return classSingleton;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton{</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void add(){</span><br><span class="line">        System.out.println("ADD - 方法");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="反射破解单例"><a href="#反射破解单例" class="headerlink" title="反射破解单例"></a>反射破解单例</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor<HungrySingleton> declaredConstructor = HungrySingleton.class.getDeclaredConstructor();</span><br><span class="line">// 设置访问私有构造</span><br><span class="line">declaredConstructor.setAccessible(true);</span><br><span class="line">// 实例化对象</span><br><span class="line">HungrySingleton hungrySingleton = declaredConstructor.newInstance();</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里通过反射获取对象，为了防止私有构造被反射可以在构造内加入判断，如果已经实例化了则直接抛出异常。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private HungrySingleton() {</span><br><span class="line">        if(hungrySingleton!=null){</span><br><span class="line">            throw new RuntimeException("单例模式不允许外界使用构造器！");</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="序列化破解"><a href="#序列化破解" class="headerlink" title="序列化破解"></a>序列化破解</h1><blockquote><p>类需要实现Serializable接口才能被序列化。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOutputStream = new FileOutputStream("/Users/Downloads/singleton.obj");</span><br><span class="line">ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);</span><br><span class="line">objectOutputStream.writeObject(v1);</span><br><span class="line">System.out.println("序列化对象成功！");</span><br><span class="line"></span><br><span class="line">FileInputStream fileInputStream = new FileInputStream("/Users/Downloads/singleton.obj");</span><br><span class="line">ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);</span><br><span class="line">HungrySingleton hungrySingleton = (HungrySingleton) objectInputStream.readObject();</span><br><span class="line">System.out.println("序列化之后的对比:" + (v1 == hungrySingleton));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这边先不说怎么预防序列化破解，我们可以先看下枚举类的源代码。<br>在反射中枚举是不能被破解的，会抛出NoSuchMethodException异常，也就是说没有无参构造，但是又可以写私有的无参构造，这里的话我是还没有弄明白为什么不能被破解。 </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 枚举类默认继承Enum 好像只有这个构造方法 无参没有</span><br><span class="line"> protected Enum(String name, int ordinal) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.ordinal = ordinal;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在反射中newInstance()方法有一段这个，也就是说枚举类不能被反射。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((clazz.getModifiers() & Modifier.ENUM) != 0)</span><br><span class="line">   throw new IllegalArgumentException("Cannot reflectively create enum objects");</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在反序列化方面枚举类也是不能被破解主要依据一下代码，还有就是clone不能克隆，父类已经把一些会被迫将的方法弄成私有化、或者final不可被继承。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream in) throws IOException,</span><br><span class="line">        ClassNotFoundException {</span><br><span class="line">        throw new InvalidObjectException("can't deserialize enum");</span><br><span class="line">    }</span><br><span class="line">private void readObjectNoData() throws ObjectStreamException {</span><br><span class="line">    throw new InvalidObjectException("can't deserialize enum");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>所以在防止破解单例的时候可以借鉴枚举类的做法，也就是刚才序列化破解如何防止的问题下，只需要把上面两个方法加载类上面就可以，也可添加readResolve方法返回实例对象，前者是不能使用，后者可以使用。  </p></blockquote><p><img alt data-src="/img/sjms/dl.png" class="lozad"></p><blockquote><p>那我们到底使用哪种形式呢？在正常开发过程中我们肯定是习惯用普通类而并非枚举类，枚举类防御效果固然好但是对于日常开发来说枚举更适用于字典形式的数据库，还是推荐使用静态内部类然后其防御性手段上面已经提到过了。</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之装饰者模式</title>
      <link href="/732405150.html"/>
      <url>/732405150.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>新手机通过好看的手机壳和膜进行装饰、原始孙悟空通过七十二变进行装饰、人通过衣服进行装饰等。  </p></blockquote><p><img alt data-src="/img/sjms/zsz.png" class="lozad">  </p><h1 id="装饰者角色"><a href="#装饰者角色" class="headerlink" title="装饰者角色"></a>装饰者角色</h1><ul><li>抽象接口</li><li>需要被装饰的实现类</li><li>装饰接口</li><li>装饰接口实现类</li></ul><h1 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Component {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 变</span><br><span class="line">     */</span><br><span class="line">    void change();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="需要被装饰的实现类"><a href="#需要被装饰的实现类" class="headerlink" title="需要被装饰的实现类"></a>需要被装饰的实现类</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MonkeyKing implements Component {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void change() {</span><br><span class="line">        System.out.println("（原型）孙悟空");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="装饰接口"><a href="#装饰接口" class="headerlink" title="装饰接口"></a>装饰接口</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Decorator implements Component {</span><br><span class="line"></span><br><span class="line">    protected Decorator(Component component) {</span><br><span class="line">        this.component = component;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected Component component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected void setComponent(Component component) {</span><br><span class="line">        this.component = component;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void change() {</span><br><span class="line">        if(component!=null){</span><br><span class="line">            component.change();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="装饰接口实现类"><a href="#装饰接口实现类" class="headerlink" title="装饰接口实现类"></a>装饰接口实现类</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class OneChange extends Decorator {</span><br><span class="line"></span><br><span class="line">    public OneChange(Component component) {</span><br><span class="line">        super(component);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void change() {</span><br><span class="line">        super.change();</span><br><span class="line">        System.out.println("（原型第一变）孙悟空 -> 猪八戒");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class TwoChange extends Decorator{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public TwoChange(Component component) {</span><br><span class="line">        super(component);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void change() {</span><br><span class="line">        super.change();</span><br><span class="line">        System.out.println("（原型第二变）孙悟空 -> 沙悟净");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>在装饰接口中的代码其实看起来有点懵逼，还有就是装饰接口实现类中的super，总所周知super代表父类其就是调用父类的方法。<br>其实在除去前两个角色之后后面的形式非常像责任链，但是顺序的话是相反的。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这种形式其实在IO流中是最常见的也就是IO流中也使用了装饰模式</span><br><span class="line">new TwoChange(new OneChange(new MonkeyKing())).change();</span><br></pre></td></tr></tbody></table></figure><h2 id="代码演变过程"><a href="#代码演变过程" class="headerlink" title="代码演变过程"></a>代码演变过程</h2><blockquote><p>如果把父类的方法放到子类中的话其实是这样的  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class OneChange extends Decorator {</span><br><span class="line"></span><br><span class="line">    protected Component component;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    protected void setComponent(Component component) {</span><br><span class="line">        this.component = component;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void change() {</span><br><span class="line">       if(component!=null){</span><br><span class="line">        component.change();</span><br><span class="line">       }</span><br><span class="line">        System.out.println("（原型第一变）孙悟空 -> 猪八戒");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>后期可能扩展有很多子类的话就很多重复代码所以就把代码放在了父类，然后子类也可以继承过来。  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TwoChange extends Decorator{</span><br><span class="line">    @Override</span><br><span class="line">    public void change() {</span><br><span class="line">        super.change();</span><br><span class="line">        System.out.println("（原型第二变）孙悟空 -> 沙悟净");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>一开始是通过反向链表的形式创造链的，之后为了方便加上了构造方法，也就是类似于IO流。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new TwoChange(new OneChange(new MonkeyKing())).change();</span><br><span class="line">new InputStreamReader(new FileInputStream(new File("11")));</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之模板方法</title>
      <link href="/220553168.html"/>
      <url>/220553168.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。<br>通过不同行为和相同行为组合成模板方法，模板方法需要先定义骨架然后子类实现不同行为，组合在一起。</p></blockquote><p><img alt data-src="/img/sjms/mbff.png" class="lozad">  </p><h1 id="抽象模板骨架"><a href="#抽象模板骨架" class="headerlink" title="抽象模板骨架"></a>抽象模板骨架</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractTemplate {</span><br><span class="line"></span><br><span class="line">    public void game() {</span><br><span class="line">        read();</span><br><span class="line">        pay();</span><br><span class="line">        settlement();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void read() {</span><br><span class="line">        System.out.println("副本读条中---------");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected abstract void pay();</span><br><span class="line"></span><br><span class="line">    protected abstract void settlement();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="抽象模板实现类"><a href="#抽象模板实现类" class="headerlink" title="抽象模板实现类"></a>抽象模板实现类</h1><blockquote><p>基于Web开发让Spring管理实现类，方便在工厂中通过BeanId获取对象。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class GoblinsOneTemplate extends AbstractTemplate {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void pay() {</span><br><span class="line">        System.out.println("哥布林副本一层攻击中-----！！！！太激烈了！！！！战斗力不行我输了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void settlement() {</span><br><span class="line">        System.out.println("战斗失败！------结算-500金币");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">@Component</span><br><span class="line">public class GoblinsTwoTemplate extends AbstractTemplate {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void pay() {</span><br><span class="line">        System.out.println("哥布林副本二层攻击中-----！！！！太弱了！！太弱了！！秒杀");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void settlement() {</span><br><span class="line">        System.out.println("战斗成功！------结算+500金币");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><blockquote><p>通过<a href="http://www.ljyanimo.com/Web%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB.html">SpringContextUtil</a>获取BeanId，如果不想通过Web测试话，可以选择使用反射来实现。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TemplateFactory {</span><br><span class="line">    public static AbstractTemplate getAbstractTemplate(String beanId){</span><br><span class="line">        return SpringContextUtil.getBean(beanId,AbstractTemplate.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote><p>通过传入BeanId(goblinsOneTemplate、goblinsTwoTemplate)</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TemplateController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/abstractTemplate/{bean}")</span><br><span class="line">    public void abstractTemplate(@PathVariable("bean") String beanId){</span><br><span class="line">        TemplateFactory.getAbstractTemplate(beanId).game();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/sjms/mbff1.png" class="lozad">   </p><blockquote><p>通过上诉简单的例子可以延伸到项目中扩大，比如源码中的HttpServlet中也是用了模板方法，我们通过实现Servlet（javax.servlet)需要实现doGet和doPost方法,每次请求经过service在里面通过请求方式来判断使用哪种方法。  </p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList fail-fast快速失败</title>
      <link href="/553781310.html"/>
      <url>/553781310.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;String&gt; integers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       ArrayListTest arrayListTest &#x3D; new ArrayListTest();</span><br><span class="line">       arrayListTest.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void start ()&#123;</span><br><span class="line">       new Thread(new ThreadOne()).start();</span><br><span class="line">       new Thread(new ThreadTwo()).start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void printAll() &#123;</span><br><span class="line">       integers.forEach((e) -&gt; System.out.println(e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class ThreadOne implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">               integers.add(i + &quot;&quot;);</span><br><span class="line">               printAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class ThreadTwo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           for (int i &#x3D; 10; i &lt; 20; ++i) &#123;</span><br><span class="line">               integers.add(i + &quot;&quot;);</span><br><span class="line">               printAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上方代码中,通过两个线程对全局变量的ArrayList进程操作,添加一次打印读取一次。<br>ArrayList中有个全局变量modCount用来记录列表被操作的次数,add和remove时会进行++。<br>代码输出结果导致异常ConcurrentModificationException。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是ArrayList实现的forEach方法</span><br><span class="line">@Override</span><br><span class="line">public void forEach(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    final int expectedModCount &#x3D; modCount;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    final E[] elementData &#x3D; (E[]) this.elementData;</span><br><span class="line">    final int size &#x3D; this.size;</span><br><span class="line">    for (int i&#x3D;0; modCount &#x3D;&#x3D; expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在多线程（同步）操作下,如果A线程打印是 modCount = 1，则expectedModCount = 1。<br>但是这时候还没有进入判断的情况下,B线程add了一下,所以modCount = 2 然后 2 != 1。<br>也就是A线程打印的时候,B线程在添加,这时候modCount的值就被修改了这种情况会导致ConcurrentModificationException。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; forEach代码片段</span><br><span class="line">final int expectedModCount &#x3D; modCount;</span><br><span class="line">if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之责任链模式</title>
      <link href="/4003944941.html"/>
      <url>/4003944941.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>责任链模式通过责任和链的形式组成，主要应用于风控系统（支付宝、银行）、Servlet中的Filter等。<br>多个责任形成一条链，类似于后台管理左侧导航栏、还有LinkedList链表。  </p></blockquote><p><img alt data-src="/img/sjms/zrl.png" class="lozad"></p><h1 id="抽象责任（AbstractHandler）"><a href="#抽象责任（AbstractHandler）" class="headerlink" title="抽象责任（AbstractHandler）"></a>抽象责任（AbstractHandler）</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GatewayHandler {</span><br><span class="line"></span><br><span class="line">    private GatewayHandler nextGatewayHandler;</span><br><span class="line"></span><br><span class="line">    public void setNextGatewayHandler(GatewayHandler gatewayHandler){</span><br><span class="line">        this.nextGatewayHandler = gatewayHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 业务逻辑</span><br><span class="line">     */</span><br><span class="line">    public abstract void service();</span><br><span class="line"></span><br><span class="line">    protected void nextService(){</span><br><span class="line">        nextGatewayHandler.service();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="责任实现（白名单、限流、认证）"><a href="#责任实现（白名单、限流、认证）" class="headerlink" title="责任实现（白名单、限流、认证）"></a>责任实现（白名单、限流、认证）</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 白名单</span><br><span class="line">public class WhiteListHandler extends GatewayHandler {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service() {</span><br><span class="line">        System.out.println("1、白名单");</span><br><span class="line">        nextService();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// 限流</span><br><span class="line">public class CurrentHandler extends GatewayHandler {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service() {</span><br><span class="line">        System.out.println("2、限流");</span><br><span class="line">        nextService();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// 认证</span><br><span class="line">public class CertificationHandler extends GatewayHandler {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service() {</span><br><span class="line">        System.out.println("3、认证");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryHandler {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过代码来指定执行顺序</span><br><span class="line">     * @return 返回第一个GatewayHandler</span><br><span class="line">     */</span><br><span class="line">    public static GatewayHandler getFirstGatewayHandler(){</span><br><span class="line">        GatewayHandler gatewayHandler1 = new WhiteListHandler();</span><br><span class="line">        GatewayHandler gatewayHandler2 = new CurrentHandler();</span><br><span class="line">        gatewayHandler1.setNextGatewayHandler(gatewayHandler2);</span><br><span class="line">        GatewayHandler gatewayHandler3 = new CertificationHandler();</span><br><span class="line">        gatewayHandler2.setNextGatewayHandler(gatewayHandler3);</span><br><span class="line">        return gatewayHandler1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>WhiteListHandler -> CurrentHandler -> CertificationHandler -> null  </p></blockquote><p><img alt data-src="/img/sjms/zrl1.png" class="lozad">  </p><h1 id="数据库形式"><a href="#数据库形式" class="headerlink" title="数据库形式"></a>数据库形式</h1><blockquote><p>上方通过工厂方式实现显然不符合web开发规范，通过@Component注解来让Spring管理我们的责任，通过数据库维护我们的责任链关系。 </p></blockquote><blockquote><p>原来责任代码实现类加上@Component让Spring管理。这里使用的是MybatisPlus进行操作。</p></blockquote><h2 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h2><h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `responsibility`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `bean_id` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'Spring中的BeanID',</span><br><span class="line">  `pre_id` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '上一节点',</span><br><span class="line">  `next_id` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '下一节点',</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></tbody></table></figure><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName("responsibility")</span><br><span class="line">public class Responsibility {</span><br><span class="line"></span><br><span class="line">    @TableId(value = "id",type = IdType.AUTO)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BeanId</span><br><span class="line">     */</span><br><span class="line">    @TableField(value = "bean_id")</span><br><span class="line">    private String beanId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上一节点</span><br><span class="line">     */</span><br><span class="line">    @TableField(value = "pre_id")</span><br><span class="line">    private String preId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下一节点</span><br><span class="line">     */</span><br><span class="line">    @TableField(value = "next_id")</span><br><span class="line">    private String nextId;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface ResponsibilityMapper extends BaseMapper<Responsibility> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="核心Service"><a href="#核心Service" class="headerlink" title="核心Service"></a>核心Service</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class GatewayService {</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ResponsibilityMapper responsibilityMapper;</span><br><span class="line"></span><br><span class="line">    private GatewayHandler gatewayHandler;</span><br><span class="line"></span><br><span class="line">    public GatewayHandler getFirstGatewayHandler(){</span><br><span class="line">        if(this.gatewayHandler!=null){</span><br><span class="line">            return this.gatewayHandler;</span><br><span class="line">        }</span><br><span class="line">        // 根据pre_id 为空的判断</span><br><span class="line">        Responsibility responsibility = responsibilityMapper.selectOne(new QueryWrapper<Responsibility>().isNull("pre_id"));</span><br><span class="line">        if(responsibility == null){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        // 获取第一个责任 白名单</span><br><span class="line">        GatewayHandler firstGatewayHandler = SpringContextUtil.getBean(responsibility.getBeanId(),GatewayHandler.class);</span><br><span class="line">        // 获取下一节点</span><br><span class="line">        String nextId = responsibility.getNextId();</span><br><span class="line">        // 判断下一节点是否存在 也就是责任链是否成立</span><br><span class="line">        if(StringUtils.isEmpty(nextId)){</span><br><span class="line">            System.out.println("请配置下一个责任！！！");</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        // 通过临时变量接收</span><br><span class="line">        GatewayHandler temp = firstGatewayHandler;</span><br><span class="line">        while (!StringUtils.isEmpty(nextId)){</span><br><span class="line">            Responsibility tempResponsibility = responsibilityMapper.selectOne(new QueryWrapper<Responsibility>().eq("bean_id",nextId));</span><br><span class="line">            GatewayHandler gatewayHandler = SpringContextUtil.getBean(tempResponsibility.getBeanId(),GatewayHandler.class);</span><br><span class="line">            temp.setNextGatewayHandler(gatewayHandler);</span><br><span class="line">            temp = gatewayHandler;</span><br><span class="line">            nextId = tempResponsibility.getNextId();</span><br><span class="line">        }</span><br><span class="line">        this.gatewayHandler = firstGatewayHandler;</span><br><span class="line">        return firstGatewayHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>其实上放的数据库设计可以在多样化一些，比如加入类型也就是责任类型（风控、流程等），其次后台管理可动态配置顺序和删减责任。  </p></blockquote><blockquote><p>具体项目中如何进行风控的具体也不太清楚没有接触过相关业务，但是责任链模式必然合适。</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写ArrayList源码分析</title>
      <link href="/596349738.html"/>
      <url>/596349738.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>基于JDK1.8的ArrayList源码分析，通过学习蚂蚁课堂源码分析记录此文章和一些自己的理解。  </p></blockquote><p><img alt data-src="/img/yuanma/arraylistkr.png" class="lozad"> </p><h1 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 默认初始容量</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">// transient标记不被序列化 空数组 存储数据</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">// 出现的位置比较少一般在有参构造和冷API中</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">// size指的是ArrayList中的元素个数</span><br><span class="line">private int size;</span><br></pre></td></tr></tbody></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) {</span><br><span class="line">       // 如果当前传入的初始容量大于0</span><br><span class="line">       if (initialCapacity > 0) {</span><br><span class="line">           this.elementData = new Object[initialCapacity];</span><br><span class="line">       } else if (initialCapacity == 0) {</span><br><span class="line">           // 如果等于0 则赋值为空数组</span><br><span class="line">           this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       } else {</span><br><span class="line">           throw new IllegalArgumentException("Illegal Capacity: "+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() {</span><br><span class="line">    // 默认无参构造 10的大小</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) {</span><br><span class="line">    // 进行扩容判断</span><br><span class="line">    ensureCapacityInternal(size + 1);</span><br><span class="line">    // 因为size为int类型 默认为0 所以第一次添加的话 elementData[0] = e</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>ensureCapacityInternal（扩容校验）内部实现代码，通过无参构造第一次进入分析。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) {</span><br><span class="line">    // minCapacity = size + 1</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">}</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) {</span><br><span class="line">    </span><br><span class="line">    // 通过无参构造第一次添加进入</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">        // DEFAULT_CAPACITY = 10 > minCapacity = size + 1</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 第一次 minCapacity = 10</span><br><span class="line">    return minCapacity;</span><br><span class="line">}</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) {</span><br><span class="line">    </span><br><span class="line">    // 这是一个对列表操作次数统计</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // 这时候minCapacity = 10 elementData.length = 0 则进入grow方法扩容也算是对第一次的初始化</span><br><span class="line">    if (minCapacity - elementData.length > 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br><span class="line">private void grow(int minCapacity) {</span><br><span class="line">    </span><br><span class="line">    // 第一次进入的话这边oldCapacity = 0</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line"></span><br><span class="line">    // 这里的扩容机制如果不太明白可以通过main方法单元测试下 这里newCapacity为0</span><br><span class="line">    // 假设oldCapacity = 4 则 oldCapacity >> 1 = 2 所以 newCapacity = 6 扩容机制为原来大小的1.5倍</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity >> 1);</span><br><span class="line"></span><br><span class="line">    // 第一次进入 0 - 10 初始化数组会进入也就是无参构造方式</span><br><span class="line">    if (newCapacity - minCapacity < 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    // 如果新扩容的长度大于Integer.MAX_VALUE - 8 一般很难进入这个方法</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE > 0) // MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    // newCapacity 最大值为 Integer.MAX_VALUE</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br><span class="line">private static int hugeCapacity(int minCapacity) {</span><br><span class="line">    if (minCapacity < 0)</span><br><span class="line">        throw new OutOfMemoryError();</span><br><span class="line"></span><br><span class="line">    // 如果minCapacity 大于 Integer.MAX_VALUE - 8</span><br><span class="line">    return (minCapacity > MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">public interface ExtList<E> {</span><br><span class="line"></span><br><span class="line">   public interface ExtList<E> {</span><br><span class="line">   </span><br><span class="line">       /**</span><br><span class="line">        * 获取元素个数</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       int size();</span><br><span class="line">   </span><br><span class="line">       /**</span><br><span class="line">        * 添加方法</span><br><span class="line">        * @param e</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       boolean add(E e);</span><br><span class="line">   </span><br><span class="line">       /**</span><br><span class="line">        *  根据下标获取元素</span><br><span class="line">        * @param index</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       E get(int index);</span><br><span class="line">   </span><br><span class="line">       /**</span><br><span class="line">        * 根据下标删除元素</span><br><span class="line">        * @param index</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">       E remove(int index);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class ExtArrayList<E> implements ExtList<E> {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认空数组</span><br><span class="line">     */</span><br><span class="line">    public static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存放元素的数组</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数组中的元素个数</span><br><span class="line">     */</span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认初始化大小</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    private transient volatile int modCount = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法不会去初始化数组大小，只有add的时候才会去初始化/扩容</span><br><span class="line">     */</span><br><span class="line">    public ExtArrayList(){</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() {</span><br><span class="line">        return size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) {</span><br><span class="line">        // 校验下一个存储位置是否足够</span><br><span class="line">        ensureCapacityInternal(size + 1);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void ensureCapacityInternal(int minCapacity){</span><br><span class="line">        // 无参构造初始化之后第一次add会进入</span><br><span class="line">        if(elementData  == DEFAULTCAPACITY_EMPTY_ELEMENTDATA){</span><br><span class="line">            // minCapacity = 10</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</span><br><span class="line">        }</span><br><span class="line">        modCount++;</span><br><span class="line">        // 如果下一个添加的位置大于当前数组长度 则进入扩容</span><br><span class="line">        if(minCapacity - elementData.length > 0){</span><br><span class="line">            // 扩容</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void grow(int minCapacity){</span><br><span class="line">        // 获取当前元素的长度</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 原长度基础上增加50% 1.5倍 相对于原数组的话是50%的说法</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity >> 1);</span><br><span class="line">        // 如果新扩容的大小减去下一个存储位置小于0 则把下一个位置赋值给扩容长度 这个判断只有第一次添加数据的时候进入</span><br><span class="line">        if(newCapacity - minCapacity < 0){</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        }</span><br><span class="line">        // 源码部分这里有一段判断当前扩容大小超过Integer大小的判断 这里不实现</span><br><span class="line">        elementData = Arrays.copyOf(elementData,newCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E remove(int index) {</span><br><span class="line">        modCount++;</span><br><span class="line">        // 获取需要删除的元素</span><br><span class="line">        E oldData = get(index);</span><br><span class="line">        // 计算需要拷贝的长度</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        // 如果删除的下标不是最后一个元素就会进入</span><br><span class="line">        if(numMoved > 0){</span><br><span class="line">            /**</span><br><span class="line">             * src 原数组</span><br><span class="line">             * srcPos 原数组起始位置</span><br><span class="line">             * dest 目标数组</span><br><span class="line">             * destPos 目标数组起始位置</span><br><span class="line">             * length 拷贝长度</span><br><span class="line">             */</span><br><span class="line">            /**</span><br><span class="line">             * 假设int index = 0;</span><br><span class="line">             * 原数组 new Object[]{'0',【‘1’】,'2','3'}; 前面两个参数</span><br><span class="line">             * 目标数组 new Object[]{【‘0’】,'1','2','3'}; 后面两个参数</span><br><span class="line">             *</span><br><span class="line">             * 拷贝长度就是通过size元素个数 减去 index - 1</span><br><span class="line">             * 这里的拷贝长度主要针对原数组所以是1的位置包括1往后推numMoved位就是要拷贝的数据</span><br><span class="line">             *</span><br><span class="line">             * 然后拷贝到目标数组的index位置也就是需要删除的位置</span><br><span class="line">             *</span><br><span class="line">             * 在把最后一个下标的数据 null</span><br><span class="line">             */</span><br><span class="line">            System.arraycopy(elementData,index + 1,elementData,index,numMoved);</span><br><span class="line">        }</span><br><span class="line">        elementData[--size] = null;</span><br><span class="line">        return oldData;</span><br><span class="line">    }</span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) {</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检测数组越界</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    private void rangeCheck(int index) {</span><br><span class="line">        if (index >= size){</span><br><span class="line">            throw new IndexOutOfBoundsException("数组越界啦！！:" + index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        ExtList<String> extList = new ExtArrayList<>();</span><br><span class="line">        extList.add("0");</span><br><span class="line">        extList.add("1");</span><br><span class="line">        extList.add("2");</span><br><span class="line">        extList.add("3");</span><br><span class="line">        extList.remove(0);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2.x取消Security验证</title>
      <link href="/3655608586.html"/>
      <url>/3655608586.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().permitAll().and().logout().permitAll();&#x2F;&#x2F;配置不需要登录验证</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序验证码校验</title>
      <link href="/2094502835.html"/>
      <url>/2094502835.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>由于小程序端wx.request封装导致无法携带cookie。<br>前端与后端保持通信通过cookie所以在登录的时候加载验证码可以把cookie保存至storage。</p></blockquote><h1 id="验证码代码"><a href="#验证码代码" class="headerlink" title="验证码代码"></a>验证码代码</h1><h2 id="随机工具类"><a href="#随机工具类" class="headerlink" title="随机工具类"></a>随机工具类</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class RandomUtils{</span><br><span class="line"></span><br><span class="line">    private static final char[] CODE_SEQ = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J',</span><br><span class="line">            'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',</span><br><span class="line">            'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7', '8', '9' };</span><br><span class="line"></span><br><span class="line">    private static final char[] NUMBER_ARRAY = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };</span><br><span class="line"></span><br><span class="line">    private static Random random = new Random();</span><br><span class="line"></span><br><span class="line">    public static String randomString(int length) {</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i < length; i++) {</span><br><span class="line">            sb.append(String.valueOf(CODE_SEQ[random.nextInt(CODE_SEQ.length)]));</span><br><span class="line">        }</span><br><span class="line">        return sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static String randomNumberString(int length) {</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i < length; i++) {</span><br><span class="line">            sb.append(String.valueOf(NUMBER_ARRAY[random.nextInt(NUMBER_ARRAY.length)]));</span><br><span class="line">        }</span><br><span class="line">        return sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static Color randomColor(int fc, int bc) {</span><br><span class="line">        int f = fc;</span><br><span class="line">        int b = bc;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        if (f > 255) {</span><br><span class="line">            f = 255;</span><br><span class="line">        }</span><br><span class="line">        if (b > 255) {</span><br><span class="line">            b = 255;</span><br><span class="line">        }</span><br><span class="line">        return new Color(f + random.nextInt(b - f), f + random.nextInt(b - f), f + random.nextInt(b - f));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static int nextInt(int bound) {</span><br><span class="line">        return random.nextInt(bound);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 验证码类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class VerifyCode {</span><br><span class="line"></span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    private byte[] imgBytes;</span><br><span class="line"></span><br><span class="line">    private long expireTime;</span><br><span class="line"></span><br><span class="line">    private String baseStr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 验证码生成接口</span><br><span class="line"> */</span><br><span class="line">public interface IVerifyCodeGen {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成验证码并返回code，将图片写的os中</span><br><span class="line">     *</span><br><span class="line">     * @param width</span><br><span class="line">     * @param height</span><br><span class="line">     * @param os</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    String generate(int width, int height, OutputStream os) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成验证码对象</span><br><span class="line">     *</span><br><span class="line">     * @param width</span><br><span class="line">     * @param height</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    VerifyCode generate(int width, int height) throws IOException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.tomcat.util.codec.binary.Base64;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 验证码实现类</span><br><span class="line"> */</span><br><span class="line">public class SimpleCharVerifyCodeGenImpl implements IVerifyCodeGen {</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(SimpleCharVerifyCodeGenImpl.class);</span><br><span class="line"></span><br><span class="line">    private static final String[] FONT_TYPES = { "\u5b8b\u4f53", "\u65b0\u5b8b\u4f53", "\u9ed1\u4f53", "\u6977\u4f53", "\u96b6\u4e66" };</span><br><span class="line"></span><br><span class="line">    private static final int VALICATE_CODE_LENGTH = 4;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置背景颜色及大小，干扰线</span><br><span class="line">     *</span><br><span class="line">     * @param graphics</span><br><span class="line">     * @param width</span><br><span class="line">     * @param height</span><br><span class="line">     */</span><br><span class="line">    private static void fillBackground(Graphics graphics, int width, int height) {</span><br><span class="line">        // 填充背景</span><br><span class="line">        graphics.setColor(Color.WHITE);</span><br><span class="line">        //设置矩形坐标x y 为0</span><br><span class="line">        graphics.fillRect(0, 0, width, height);</span><br><span class="line"></span><br><span class="line">        // 加入干扰线条</span><br><span class="line">        for (int i = 0; i < 8; i++) {</span><br><span class="line">            //设置随机颜色算法参数</span><br><span class="line">            graphics.setColor(RandomUtils.randomColor(40, 150));</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            int x = random.nextInt(width);</span><br><span class="line">            int y = random.nextInt(height);</span><br><span class="line">            int x1 = random.nextInt(width);</span><br><span class="line">            int y1 = random.nextInt(height);</span><br><span class="line">            graphics.drawLine(x, y, x1, y1);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成随机字符</span><br><span class="line">     *</span><br><span class="line">     * @param width</span><br><span class="line">     * @param height</span><br><span class="line">     * @param os</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String generate(int width, int height, OutputStream os) throws IOException {</span><br><span class="line">        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        Graphics graphics = image.getGraphics();</span><br><span class="line">        fillBackground(graphics, width, height);</span><br><span class="line">        String randomStr = RandomUtils.randomString(VALICATE_CODE_LENGTH);</span><br><span class="line">        createCharacter(graphics, randomStr);</span><br><span class="line">        graphics.dispose();</span><br><span class="line">        //设置JPEG格式</span><br><span class="line">        ImageIO.write(image, "JPEG", os);</span><br><span class="line">        return randomStr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证码生成</span><br><span class="line">     *</span><br><span class="line">     * @param width</span><br><span class="line">     * @param height</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public VerifyCode generate(int width, int height) {</span><br><span class="line">        VerifyCode verifyCode = null;</span><br><span class="line">        try (</span><br><span class="line">                //将流的初始化放到这里就不需要手动关闭流</span><br><span class="line">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ) {</span><br><span class="line">            String code = generate(width, height, baos);</span><br><span class="line">            verifyCode = new VerifyCode();</span><br><span class="line">            verifyCode.setCode(code);</span><br><span class="line">            verifyCode.setImgBytes(baos.toByteArray());</span><br><span class="line">            verifyCode.setBaseStr(Base64.encodeBase64String(baos.toByteArray()));</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            verifyCode = null;</span><br><span class="line">        }</span><br><span class="line">        return verifyCode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置字符颜色大小</span><br><span class="line">     *</span><br><span class="line">     * @param g</span><br><span class="line">     * @param randomStr</span><br><span class="line">     */</span><br><span class="line">    private void createCharacter(Graphics g, String randomStr) {</span><br><span class="line">        char[] charArray = randomStr.toCharArray();</span><br><span class="line">        for (int i = 0; i < charArray.length; i++) {</span><br><span class="line">            //设置RGB颜色算法参数</span><br><span class="line">            g.setColor(new Color(50 + RandomUtils.nextInt(100),</span><br><span class="line">                    50 + RandomUtils.nextInt(100), 50 + RandomUtils.nextInt(100)));</span><br><span class="line">            //设置字体大小，类型</span><br><span class="line">            g.setFont(new Font(FONT_TYPES[RandomUtils.nextInt(FONT_TYPES.length)], Font.BOLD, 26));</span><br><span class="line">            //设置x y 坐标</span><br><span class="line">            g.drawString(String.valueOf(charArray[i]), 15 * i + 5, 19 + RandomUtils.nextInt(8));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/verifyCode")</span><br><span class="line">public ServerResponseVo verifyCode(HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">    IVerifyCodeGen iVerifyCodeGen = new SimpleCharVerifyCodeGenImpl();</span><br><span class="line">    try {</span><br><span class="line">        //设置长宽</span><br><span class="line">        VerifyCode verifyCode = iVerifyCodeGen.generate(80, 28);</span><br><span class="line">        String code = verifyCode.getCode();</span><br><span class="line">        System.err.println("code:"+code);</span><br><span class="line">        //将VerifyCode绑定session</span><br><span class="line">        request.getSession().setAttribute("VerifyCode", code);</span><br><span class="line">        //设置响应头</span><br><span class="line">        response.setHeader("Pragma", "no-cache");</span><br><span class="line">        //设置响应头</span><br><span class="line">        response.setHeader("Cache-Control", "no-cache");</span><br><span class="line">        //在代理服务器端防止缓冲</span><br><span class="line">        response.setDateHeader("Expires", 0);</span><br><span class="line">        //设置响应内容类型</span><br><span class="line">        response.setContentType("image/jpeg");</span><br><span class="line">//            response.getOutputStream().write(verifyCode.getImgBytes());</span><br><span class="line">//            response.getOutputStream().flush();</span><br><span class="line">        System.out.println(response.getHeader("Set-Cookie"));</span><br><span class="line">        return ServerResponseVo.createBySuccess(verifyCode);</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    return null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><blockquote><p>解决验证码验证问题,所以选择在登录页面的onLoad声明周期时请求验证码。<br>可能获取验证码是直接通过url放在img标签的src属性下,但是这样做无法保存cookie也就没办法与后端校验,所以这里改成了生命周期以及返回base64编码的方式。</p></blockquote><h2 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const that = this;</span><br><span class="line">wx.request({</span><br><span class="line">  url: app.globalData.backgroundUrl+'verifyCode',</span><br><span class="line">  header: {</span><br><span class="line">    'content-type': 'application/octet-stream',</span><br><span class="line">  },</span><br><span class="line">  method: 'GET',</span><br><span class="line">  complete(res) {</span><br><span class="line">    if (res.data.code == 0) {</span><br><span class="line">      wx.setStorageSync('verifyCookie', res.header["Set-Cookie"])</span><br><span class="line">      that.setData({</span><br><span class="line">        imgUrl: 'data:image/png;base64,' + res.data.data.baseStr</span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="刷新验证码"><a href="#刷新验证码" class="headerlink" title="刷新验证码"></a>刷新验证码</h2><blockquote><p>在image标签绑定一个事件具体js代码如上述代码一样可封装成一个公共用的方法,这里不再贴出。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><image  bindtap="refreshImg" class="weui-vcode-img" src="{{imgUrl}}" style="width: 80px"></image></span><br></pre></td></tr></tbody></table></figure><h2 id="登录请求"><a href="#登录请求" class="headerlink" title="登录请求"></a>登录请求</h2><blockquote><p>在原来请求代码中加入请求头并且把storage存的cookie放入进去这样后端就能获取与之对应的验证码。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header: {</span><br><span class="line">    'cookie': wx.getStorageSync('verifyCookie'),</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><blockquote></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String code = (String)request.getSession().getAttribute("VerifyCode");</span><br><span class="line">if(!userLogin.getVerifyCode().equalsIgnoreCase(code)){</span><br><span class="line">    return ServerResponseVo.createByError("验证码错误");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/xcx/1.png" class="lozad"><br><img alt data-src="/img/xcx/2.png" class="lozad">  </p><blockquote><p>上诉代码考虑的点并不是很严谨,包含了验证码校验时间和登录成功清除验证码，以及验证码更加灵活的封装和生产验证码时保存session的值应该考虑成VerifyCode对象比较合适。</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/2580072625.html"/>
      <url>/2580072625.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。<br>将共同的行为封装成策略接口,不同策略实现类只需要实现策略接口编写自己的业务代码,通过上下文获取策略类（多态机制）</p></blockquote><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h3><blockquote><p>上下文角色主要作用于操作策略方法,屏蔽了高层模块对策略的直接访问。</p></blockquote><h3 id="抽象策略（Strategy）"><a href="#抽象策略（Strategy）" class="headerlink" title="抽象策略（Strategy）"></a>抽象策略（Strategy）</h3><blockquote><p>对共有的行为进行封装。</p></blockquote><h3 id="具体策略（ConcreteStrategy）"><a href="#具体策略（ConcreteStrategy）" class="headerlink" title="具体策略（ConcreteStrategy）"></a>具体策略（ConcreteStrategy）</h3><blockquote><p>实现抽象策略的具体操作。</p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote><p>避免多重条件判断语句，多重判断不易于维护管理，而且判断和行为逻辑混用。</p></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote><p>客户端（调用者）必须要知道所有的策略类，并且自定决定用哪一个策略类，策略模式只适用于客户端知情的情况。</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>1、多个类只在行为上有稍微不同的场景。<br>2、策略自由切换。<br>3、聚合登录、聚合支付。  </p></blockquote><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">是否看过这样的代码？（伪代码）</span><br><span class="line">public Map login(String loginType){</span><br><span class="line">    if(loginType.equals("QQ")){</span><br><span class="line">        System.out.print("QQ登录");</span><br><span class="line">    }else if(loginType.equals("WECHAT")){</span><br><span class="line">        System.out.print("微信登录");</span><br><span class="line">    }else if(loginType.equals("ali")){</span><br><span class="line">         System.out.print("支付宝登录");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/sjms/ifelse.png" class="lozad">   </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实际上我们采用策略模式可以简化很多。</span><br><span class="line">public Map login(String loginType){</span><br><span class="line">    StrategyContext.login(loginType);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/sjms/sf.gif" class="lozad">   </p><blockquote><p>今天项目可能要接入QQ第三方登录，我们需要编写QQ登录的业务逻辑，老板哪天开心了又要接入微信登录这时候你又写了个微信的类，可有一天QQ不想支持登录了那你又得修改代码重新编译。<br>为了应付老板这种多变的需求这时候设计模式就出现啦，策略模式你值得拥有，上代码！</p></blockquote><p>通过策略模式的三个角色我们可以发现，首先我们需要找出共同行为封装成一个接口策略类（Strategy）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里采用伪代码的形式封装了一个登陆的共同行为。</span><br><span class="line"> */</span><br><span class="line">public interface LoginStrategy {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录</span><br><span class="line">     */</span><br><span class="line">    void login();    </span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>策略的具体实现类伪代码两个类（QQ、WECHAT）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class QQLoginStrategy implements LoginStrategy {</span><br><span class="line">    @Override</span><br><span class="line">    public void login() {</span><br><span class="line">        System.out.println("QQ登录");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">public class WechatLoginStrategy implements LoginStrategy {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void login() {</span><br><span class="line">        System.out.println("微信登录");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里采用工厂类来初始化对象。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LoginStrategyFactory {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 采用反射机制获取Class，所以需要有地方维护classpath（枚举）</span><br><span class="line">     *</span><br><span class="line">     * @param strategyType</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static LoginStrategy getLoginStrategy(String strategyType){</span><br><span class="line">        try {</span><br><span class="line">            String classPath = LoginEnum.valueOf(strategyType).getClassPath();</span><br><span class="line">            return (LoginStrategy) Class.forName(classPath).newInstance();</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>维护策略类classpath。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum  LoginEnum {</span><br><span class="line">    QQ("com.animo.strategy.impl.QQLoginStrategy"),</span><br><span class="line">    WECHAT("com.animo.strategy.impl.WechatLoginStrategy");</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    LoginEnum(String classPath) {</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getClassPath() {</span><br><span class="line">        return classPath;</span><br><span class="line">    }</span><br><span class="line">    public void setClassPath(String classPath) {</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上下文具体实现策略。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LoginContextStrategy {</span><br><span class="line">    /**</span><br><span class="line">     * 这里按具体业务返回 这边就直接void了</span><br><span class="line">     * @param strategyType</span><br><span class="line">     */</span><br><span class="line">    public void login(String strategyType){</span><br><span class="line">        if(strategyType==null || ("").equals(strategyType)){</span><br><span class="line">            System.out.println("strategyType不能为空");</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        LoginStrategy loginStrategy = LoginStrategyFactory.getLoginStrategy(strategyType);</span><br><span class="line">        if(loginStrategy==null){</span><br><span class="line">            System.out.println("没有找到具体实现");</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        loginStrategy.login();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以上代码包含包含四个角色比策略模式所说的三个角色多了一个工厂类，其工厂类的作用就是多态的调用实现类。<br>不过这代码不适用于Web开发，可以看得出只要每一次访问工厂类中的策略类都会重新创建，只需要稍微改造一下即可。</p></blockquote><p><img alt data-src="/img/sjms/hhh.png" class="lozad">    </p><p>我们首先需要在策略类上面加上@Component注解使其让Spring管理（单例）性能提升。  </p><p>随后工厂类肯定就不需要啦，通过Spring管理肯定就是通过ApplicationContext上下文进行获取。  </p><p>通过Spring获取的话也不需要classpath了，采用的是类首字母小写的形式获取。  </p><p>在之前通过枚举类去维护classpath，转变成了数据维护。  </p><p>当然转成数据库维护就要用到mybatis啦具体查询代码就不展示。</p><p>数据库表设计</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自增ID</span><br><span class="line">策略描述（QQ登录、微信登录）</span><br><span class="line">策略Type（QQ、WECHAT）</span><br><span class="line">BeanId</span><br><span class="line">status（开关，可以用于控制通道是否开启）</span><br></pre></td></tr></tbody></table></figure><p>策略实现类</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头部加入@Component让Spring管理</span><br></pre></td></tr></tbody></table></figure><p>上下文。<br> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class LoginContextStrategy {</span><br><span class="line"></span><br><span class="line">    private Mapper mapper;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">     * 这里按具体业务返回 这边就直接void了</span><br><span class="line">     * @param strategyType</span><br><span class="line">     */</span><br><span class="line">    public void login(String strategyType){</span><br><span class="line">        if(strategyType==null || ("").equals(strategyType)){</span><br><span class="line">            System.out.println("strategyType不能为空");</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        /**</span><br><span class="line">         * 1、 通过数据查询具体的策略实现Bean（判断是否有该渠道）</span><br><span class="line">         *</span><br><span class="line">         * 2、获取BeanId（数据库存在渠道但是没有配置该字段）</span><br><span class="line">         *</span><br><span class="line">         * 通过SpringUtils获取Bean</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line">          Entity entity = mapper.getChannel(strategyType);</span><br><span class="line">           if(entity == null ){</span><br><span class="line">                // 没有找到具体的策略实现类</span><br><span class="line">           }</span><br><span class="line">        String beanId = entity.getBeanId();</span><br><span class="line">           if(//判断是否有BeanId){</span><br><span class="line">               // 没有配置 BeanId</span><br><span class="line">            }</span><br><span class="line">        //还可以在判断是否关闭了某个登录策略</span><br><span class="line">        // SpringUtils这个工具类需自己编写</span><br><span class="line">        LoginStrategy loginStrategy = SpringUtils.getBean(beanId,LoginStrategy.class);</span><br><span class="line">        // loginStrategy 会采用多态的机制去调用对应的实现类方法</span><br><span class="line">        loginStrategy.login();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>在项中我们只需要传入策略类型即可，例如我们采用聚合登录的例子来展示了策略模式，则Controller中就有这个一个方法。<p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Map login(String loginType){</span><br><span class="line">    LoginContextStrategy.login(loginType);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/sjms/js.png" class="lozad">   </p></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装kibana</title>
      <link href="/1026749055.html"/>
      <url>/1026749055.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Kibana是一个为Elasticsearch平台分析和可视化的开源平台，使用Kibana能够搜索、展示存储在Elasticsearch中的索引数据。使用它可以很方便用图表、表格、地图展示和分析数据。Kibana能够轻松处理大量数据，通过浏览器接口能够轻松的创建和分享仪表盘，通过改变Elasticsearch查询时间，可以完成动态仪表盘。</p></blockquote><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;kibana&#x2F;kibana-7.5.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar vxf kibana-7.5.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>1、基础配置(config/kibana.yml),其他配置的话文件里都有说明可自行翻译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.hosts: &quot;http:&#x2F;&#x2F;localhost:9200&quot;</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>1、脚本(bin目录创建/路径按需修改)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh &#x2F;usr&#x2F;app&#x2F;kibana-7.5.1-linux-x86_64&#x2F;bin&#x2F;kibana --allow-root &gt; &#x2F;usr&#x2F;app&#x2F;logs&#x2F;kibana-7.5.1&#x2F;logs&#x2F;kibana.out &amp;</span><br></pre></td></tr></table></figure><p>2、执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x kibanaStart.sh</span><br></pre></td></tr></table></figure><p>3、启动脚本/访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;kibanaStart.sh </span><br><span class="line">http:&#x2F;&#x2F;localhost:5601</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Logstash</title>
      <link href="/412919364.html"/>
      <url>/412919364.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>Logstash作为ELK中的一员其主要作用收集日志、处理日志、转发。</p></blockquote><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>1、可更改版本号来实现各版本号的下载</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://artifacts.elastic.co/downloads/logstash/logstash-7.5.1.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>2、项目主页</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.elastic.co/cn/downloads/logstash</span><br></pre></td></tr></tbody></table></figure><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar vxf logstash-7.5.1.tar.gz</span><br></pre></td></tr></tbody></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>1、在logstash目录下创建conf.d文件夹</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir conf.d</span><br></pre></td></tr></tbody></table></figure><p>2、在conf.d目录下创建config1.conf文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch config1.conf</span><br></pre></td></tr></tbody></table></figure><p>3、文件内容配置写入,工作流程（采集 -> 过滤 -> 写出）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">input{</span><br><span class="line">    # 采集本地文件</span><br><span class="line">    file{</span><br><span class="line">        path=> "/root/logs/*.log"</span><br><span class="line">        # 采集策略 从什么位置采集</span><br><span class="line">        start_position => beginning</span><br><span class="line">        # 来源名称 可选</span><br><span class="line">        add_field => {"form" => "localfile"}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"># 采集过来的数据以什么方式过滤</span><br><span class="line">filter{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"># 写入到什么地方去</span><br><span class="line">output{</span><br><span class="line">    elasticsearch{</span><br><span class="line">        hosts => "localhost:9200"</span><br><span class="line">        index => "mylog"</span><br><span class="line">    }</span><br><span class="line">    stdout{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>1、编写sh脚本(目录根据自己的修改)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh /usr/app/logstash-7.5.1/bin/logstash -f /usr/app/logstash-7.5.1/conf.d/ --config.reload.automatic >> /usr/app/logs/logstash-7.5.1/logs/logstash.log &</span><br></pre></td></tr></tbody></table></figure><p>2、加权限</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x logstashStart.sh</span><br></pre></td></tr></tbody></table></figure><p>3、启动</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logstashStart.sh</span><br></pre></td></tr></tbody></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>1、其次先去Es创建索引库,这里采用ElasticSearch-Head创建可查看本博客之前教程 <a href="http://www.ljyanimo.com/Docker%E5%AE%89%E8%A3%85ElasticSearch.html">http://www.ljyanimo.com/Docker%E5%AE%89%E8%A3%85ElasticSearch.html</a></p><p>2、大家可以根据上面教程在本地装一个通过node.js构建一下即可。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引库名称为配置文件中填写的mylog</span><br></pre></td></tr></tbody></table></figure><p>3、之前配置文件写入的地址是/root/logs/*.log的所有日志。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /root/logs/test.log</span><br></pre></td></tr></tbody></table></figure><p>4、测试结果。<br><img alt data-src="/img/linux/logstash.png" class="lozad">  </p><blockquote><p>留下猜测结论,conf.d文件下的所有配置文件都会被logstash所读取并且执行好处就是多种通道单独配置,其次可以动手试试filter和修改采集策略,也可以从数据库采集到es。</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装IK分词器</title>
      <link href="/3827847771.html"/>
      <url>/3827847771.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h1><blockquote><p>默认情况下对中文的分词结果为单个字拆开,对英文分词比较友好。  </p></blockquote><h2 id="默认英文分词"><a href="#默认英文分词" class="headerlink" title="默认英文分词"></a>默认英文分词</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/_analyze -X POST -H 'Content-Type:application/json' -d '{"text":"I like Spring"}'</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分词内容:</span><br><span class="line">    I like Spring</span><br><span class="line">分词结果:</span><br><span class="line">    {"tokens":[</span><br><span class="line">    {"token":</span><br><span class="line">        "i","start_offset":0,"end_offset":1,"type":"<ALPHANUM>","position":0},</span><br><span class="line">    {"token":</span><br><span class="line">        "like","start_offset":2,"end_offset":6,"type":"<ALPHANUM>","position":1},</span><br><span class="line">    {"token":</span><br><span class="line">        "spring","start_offset":7,"end_offset":13,"type":"<ALPHANUM>","position":2}]}</span><br></pre></td></tr></tbody></table></figure><h2 id="默认中文分词"><a href="#默认中文分词" class="headerlink" title="默认中文分词"></a>默认中文分词</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/_analyze -X POST -H 'Content-Type:application/json' -d '{"text":"中华人民共和国"}'</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">分词内容:</span><br><span class="line">    中华人民共和国</span><br><span class="line">分词内容:</span><br><span class="line">    {"tokens":[</span><br><span class="line">    {"token":</span><br><span class="line">        "中","start_offset":0,"end_offset":1,"type":"<IDEOGRAPHIC>","position":0},</span><br><span class="line">    {"token":</span><br><span class="line">        "华","start_offset":1,"end_offset":2,"type":"<IDEOGRAPHIC>","position":1},</span><br><span class="line">    {"token":</span><br><span class="line">        "人","start_offset":2,"end_offset":3,"type":"<IDEOGRAPHIC>","position":2},</span><br><span class="line">    {"token":</span><br><span class="line">        "民","start_offset":3,"end_offset":4,"type":"<IDEOGRAPHIC>","position":3},</span><br><span class="line">    {"token":</span><br><span class="line">        "共","start_offset":4,"end_offset":5,"type":"<IDEOGRAPHIC>","position":4},</span><br><span class="line">    {"token":</span><br><span class="line">        "和","start_offset":5,"end_offset":6,"type":"<IDEOGRAPHIC>","position":5},</span><br><span class="line">    {"token":</span><br><span class="line">        "国","start_offset":6,"end_offset":7,"type":"<IDEOGRAPHIC>","position":6}]}</span><br></pre></td></tr></tbody></table></figure><h2 id="IK分词器下的中文分词"><a href="#IK分词器下的中文分词" class="headerlink" title="IK分词器下的中文分词"></a>IK分词器下的中文分词</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/_analyze -X POST -H 'Content-Type:application/json' -d '{"text":"中华人民共和国","analyzer":"ik_max_word"}'</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">分词内容:</span><br><span class="line">    中华人民共和国</span><br><span class="line">分词内容:</span><br><span class="line">    {"tokens":[</span><br><span class="line">    {"token":</span><br><span class="line">        "中华人民共和国","start_offset":0,"end_offset":7,"type":"CN_WORD","position":0},</span><br><span class="line">    {"token":</span><br><span class="line">        "中华人民","start_offset":0,"end_offset":4,"type":"CN_WORD","position":1},</span><br><span class="line">    {"token":</span><br><span class="line">        "中华","start_offset":0,"end_offset":2,"type":"CN_WORD","position":2},</span><br><span class="line">    {"token":</span><br><span class="line">        "华人","start_offset":1,"end_offset":3,"type":"CN_WORD","position":3},</span><br><span class="line">    {"token":</span><br><span class="line">        "人民共和国","start_offset":2,"end_offset":7,"type":"CN_WORD","position":4},</span><br><span class="line">    {"token":</span><br><span class="line">        "人民","start_offset":2,"end_offset":4,"type":"CN_WORD","position":5},</span><br><span class="line">    {"token":</span><br><span class="line">        "共和国","start_offset":4,"end_offset":7,"type":"CN_WORD","position":6},</span><br><span class="line">    {"token":</span><br><span class="line">        "共和","start_offset":4,"end_offset":6,"type":"CN_WORD","position":7},</span><br><span class="line">    {"token":</span><br><span class="line">        "国","start_offset":6,"end_offset":7,"type":"CN_CHAR","position":8}]}</span><br></pre></td></tr></tbody></table></figure><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># IK分词器要跟随ES的版本进行下载</span><br><span class="line"></span><br><span class="line">https://github.com/medcl/elasticsearch-analysis-ik/releases</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/linux/ikes.png" class="lozad"></p><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip elasticsearch-analysis-ik-7.5.1 -d /usr/app/elasticsearch-7.5.1/plugins/ik</span><br></pre></td></tr></tbody></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>1、进入plugins目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R elsearch.elsearch ik</span><br></pre></td></tr></tbody></table></figure><p>2、重启ES</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntlp | grep 9200</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcp  0  0 0.0.0.0:9200  0.0.0.0:*  LISTEN  10930/java </span><br><span class="line"></span><br><span class="line"># 杀掉进程</span><br><span class="line">kill -9 10930</span><br><span class="line"></span><br><span class="line">cd 进入到bin目录（记得非root用户启动）</span><br><span class="line"></span><br><span class="line">./elasticsearchStart.sh</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装ElasticSearch</title>
      <link href="/1073738149.html"/>
      <url>/1073738149.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>1、下载地址: <a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>2、鼠标右键Linux选择复制链接地址  </p><p>3、在linux找到合适的位置输入命令  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.1-linux-x86_64.tar.gz</span><br></pre></td></tr></tbody></table></figure><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p>1、解压之后会得到名为elasticsearch-7.5.1的文件夹.  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar vxf elasticsearch-7.5.1-linux-x86_64.tar.gz</span><br></pre></td></tr></tbody></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>1、/xxxx/elasticsearch7.5.1/config/elasticsearch.yml</p><p>2、主机名查看命令 hostname</p><p>3、vim elasticsearch.yml</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster.initial_master_nodes:["主机名"]</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: "*"</span><br></pre></td></tr></tbody></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>1、前台启动</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></tbody></table></figure><p>2、后台启动(守护进程)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></tbody></table></figure><p>3、脚本启动</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearchStart.sh</span><br><span class="line"></span><br><span class="line">脚本内容如下:</span><br><span class="line">    nohup sh bin路径/elasticsearch > 日志目录全路径 &</span><br><span class="line">例如:</span><br><span class="line">    nohup sh /usr/elasticsearch-7.5.1/bin/elasticsearch > /usr/app/logs/elasticsearch-7.5.1/logs/log.out &</span><br><span class="line"></span><br><span class="line"># 赋予执行权限</span><br><span class="line">chmod +x elasticsearchStart.sh</span><br><span class="line"></span><br><span class="line">./elasticsearchStart.sh</span><br><span class="line"></span><br><span class="line">#如果按照我的目录的话可能会出现无权限访问log.out,可以对整个logs目录做权限对刚才上面创建的用户权限。</span><br><span class="line">chown -R elsearch.elsearch logs(需要进入这个目录下/usr/app/logs/elasticsearch-7.5.1)</span><br></pre></td></tr></tbody></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="root用户无法启动"><a href="#root用户无法启动" class="headerlink" title="root用户无法启动"></a>root用户无法启动</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: can not run elasticsearch as root</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/linux/cannotroot.png" class="lozad">  </p><p>1、创建elsearch用户组及elsearch用户 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd elsearch</span><br></pre></td></tr></tbody></table></figure><p>2、向组里面添加用户 前者elastic为组名 后者elastic为用户名 elastisearch为密码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd elsearch -g elsearch -p elasticsearch</span><br></pre></td></tr></tbody></table></figure><p>3、更改elasticsearch文件及内部文件的所属用户及组为elsearch.elsearch,命令中elasticsearch-7.5.1是文件名称。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R elsearch.elsearch elasticsearch-7.5.1</span><br></pre></td></tr></tbody></table></figure><h3 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bound or publishing to a non-loopback address, enforcing bootstrap checks</span><br><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></tbody></table></figure><p>1、在/etc/sysctl.conf加入如下配置(需要切换回root用户)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></tbody></table></figure><p>2、让配置生效</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器安装MariaDB</title>
      <link href="/1106098969.html"/>
      <url>/1106098969.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。<br>在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。<br>MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。<br>MariaDB名称来自Michael Widenius的女儿Maria的名字。</p></blockquote><h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb  #启动MariaDB</span><br><span class="line"></span><br><span class="line">systemctl stop mariadb  #停止MariaDB</span><br><span class="line"></span><br><span class="line">systemctl restart mariadb  #重启MariaDB</span><br><span class="line"></span><br><span class="line">systemctl enable mariadb  #设置开机启动</span><br></pre></td></tr></tbody></table></figure><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查是否存在MariaDB,一般新的CentOS7.x默认存在。</span><br><span class="line">rpm -qa | grep mariadb</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/linux/1111.png" class="lozad"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">yum -y install mariadb mariadb-server</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">systemctl start mariadb</span><br><span class="line"></span><br><span class="line"># 自启</span><br><span class="line">systemctl enable mariadb</span><br><span class="line"></span><br><span class="line"># 密码</span><br><span class="line">mysqladmin -u root password 'root'</span><br></pre></td></tr></tbody></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 本机连接</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"># 支持远程连接</span><br><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">select user,host from user;</span><br><span class="line"></span><br><span class="line">update user set host='%' where user='root';</span><br><span class="line"># 出现Duplicate entry '%-root' for key 'PRIMARY'错误可以无视。（主键问题）</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>Access denied for user ‘root’@’localhost’ (using password: YES)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">在[mysqld]下方加入skip-grant-tables</span><br><span class="line"></span><br><span class="line"># 重启数据库</span><br><span class="line">systemctl restart mariadb</span><br><span class="line"></span><br><span class="line"># 无需输入密码直接回车</span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line"># 修改密码 123位密码</span><br><span class="line">grant all on *.* to root@'localhost' identified by '123';</span><br><span class="line"></span><br><span class="line">exit;</span><br><span class="line"></span><br><span class="line"># 把之前的skip-grant-tables注释掉</span><br><span class="line">vim /etc/my.cnf </span><br><span class="line"></span><br><span class="line"># 重启数据库</span><br><span class="line">systemctl restart mariadb</span><br></pre></td></tr></tbody></table></figure></li><li><p>The MariaDB server is running with the –skip-grant-tables option so it cannot execute this statement</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure></li><li><p>job for mariadb.service failed because the control process exited with error  code .<br>See “systemctl status mariadb.service” and “journalctl -xe” for details</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mariadb/mariadb.log</span><br><span class="line"></span><br><span class="line">200211 13:02:58 [ERROR] /usr/libexec/mysqld: unknown variable 'atadir=/var/lib/mysql'</span><br><span class="line"></span><br><span class="line"># 这是我出现该问题导致的结果,由于修改/etc/my.cnf的时候不小心删除了一个d导致死活启动不起来。</span><br></pre></td></tr></tbody></table></figure></li><li><p>远程连接失败<br><img alt data-src="/img/linux/2222.png" class="lozad"></p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器安装JDK1.8</title>
      <link href="/860962813.html"/>
      <url>/860962813.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="镜像市场"><a href="#镜像市场" class="headerlink" title="镜像市场"></a>镜像市场</h1><h2 id="实例控制台"><a href="#实例控制台" class="headerlink" title="实例控制台"></a>实例控制台</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入管理控制台选择云服务器进入到此页面,其次选择更多实例状态选择停止。</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/linux/shilikongzhitai.png" class="lozad">  </p><h2 id="镜像市场-1"><a href="#镜像市场-1" class="headerlink" title="镜像市场"></a>镜像市场</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">然后点击更多有个'磁盘和镜像'的选项点击'更换操作系统',然后选择镜像类型为镜像市场,在点击'从镜像市场选择（含操作系统）'。</span><br><span class="line"></span><br><span class="line">按照下方图片筛选选择合适的版本即可注意费用基本全是0元。</span><br><span class="line"></span><br><span class="line">点击相对于的蓝色标题可进入镜像系统详情页,有相关安装的目录和操作手册。</span><br><span class="line"></span><br><span class="line">建议使用之前先把自己选择合适的镜像系统详情页保存起来,以防后期找不到。</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/linux/jingxiangshic.png" class="lozad"></p><h1 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h1><blockquote><p>操作系统登录密码修改进入云服务器实例,更多 -> 密码/密钥 -> 重置实例密码,重启生效。</p></blockquote><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这是一款Windows上使用的远程连接工具包含SSH和FTP。</span><br><span class="line"></span><br><span class="line">https://pan.baidu.com/s/1vtfXo5qWzxqEV9AB-CszNw</span><br><span class="line">密码:kdxl</span><br><span class="line"></span><br><span class="line">下载安装之后应用名称为Xmanager Enterprise 5。</span><br><span class="line"></span><br><span class="line">双击之后选择Xshell即可。</span><br></pre></td></tr></tbody></table></figure><h3 id="连接服务器-1"><a href="#连接服务器-1" class="headerlink" title="连接服务器"></a>连接服务器</h3><p><img alt data-src="/img/linux/ssh.png" class="lozad"><br><img alt data-src="/img/linux/accountPassword.png" class="lozad"> </p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img alt data-src="/img/linux/upload.png" class="lozad"></p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><h3 id="连接服务器-2"><a href="#连接服务器-2" class="headerlink" title="连接服务器"></a>连接服务器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打开Mac命令窗口。</span><br><span class="line"># IP = 公网/私有;输入实例密码即可。</span><br><span class="line"></span><br><span class="line">ssh -p 22 root@IP</span><br></pre></td></tr></tbody></table></figure><h3 id="文件上传-1"><a href="#文件上传-1" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 以下路径都是全路径 比如: /var/xxx/acc.txt。</span><br><span class="line">scp -r 本地  root@IP:系统路径</span><br><span class="line"></span><br><span class="line">scp -r /Users/xxxx/Downloads/jhm.txt root@127.0.0.1:/var/test1/</span><br><span class="line"></span><br><span class="line"># 后者的路径需要存在不然报错,且如果不以/结尾则会替换。</span><br></pre></td></tr></tbody></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/s/1fbL4PGtTcCaSjFQYjE-CPw</span><br><span class="line">密码:04s8</span><br></pre></td></tr></tbody></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/java # 创建目录</span><br><span class="line"># JDK压缩包使用FTP上传。</span><br><span class="line">cd /usr/java </span><br><span class="line">tar -zxvf jdk-8u211-linux-x64.tar.gz # 解压</span><br></pre></td></tr></tbody></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># vim操作不懂可百度这里跳过。</span><br><span class="line"></span><br><span class="line">vim /etc/profile # 打开配置文件,最后面配置下方代码,文件名称记得改下。</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">export JRE_HOME=${JAVA_HOME}/jre</span><br><span class="line">export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH</span><br><span class="line">export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin</span><br><span class="line">export PATH=$PATH:${JAVA_PATH}</span><br><span class="line"></span><br><span class="line"># 刷新配置</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java</span><br><span class="line">javac</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker命令大全</title>
      <link href="/4086009561.html"/>
      <url>/4086009561.html</url>
      
        <content type="html"><![CDATA[<h1 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h1><h2 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># https:&#x2F;&#x2F;hub.docker.com&#x2F; 还可以上官方镜像仓库查询有相关的简单使用和版本</span><br><span class="line"># 默认搜索Docker Hub官方仓库中的镜像</span><br><span class="line"># 根据星级（start）评价进行排序</span><br><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果未指定标签则docker会使用默认的latest最新版。</span><br><span class="line"># 格式：docker pull NAME[:TAG]</span><br><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h2 id="镜像信息"><a href="#镜像信息" class="headerlink" title="镜像信息"></a>镜像信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 获取镜像列表</span><br><span class="line">docker images</span><br><span class="line"># 根据IMAGE ID获取该镜像的具体信息</span><br><span class="line">docker inspect IMAGE ID</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">REPOSITORY</th><th align="center">TAG</th><th align="center">IMAGE_ID</th><th align="center">IMAGE_ID</th><th align="center">SIZE</th></tr></thead><tbody><tr><td align="center">redis</td><td align="center">5.0.6</td><td align="center">de25a81a5a0b</td><td align="center">2 months ago</td><td align="center">98.2MB</td></tr><tr><td align="center">来自什么仓库</td><td align="center">标签信息（版本）</td><td align="center">镜像ID</td><td align="center">创建时间</td><td align="center">大小</td></tr></tbody></table><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果存在容器则会删除失败但是可以通过-f参数强制性的删除这样会造成问题</span><br><span class="line"># 正确操作：删除依赖该镜像的所有容器 -&gt; 删除镜像 </span><br><span class="line"># 删除容器 </span><br><span class="line">docker rm CONTAINER ID</span><br><span class="line"># 删除镜像</span><br><span class="line">docker rmi IMAGE ID</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker create -it mysql</span><br><span class="line"># 被创建的容器是处于停止状态还需要使用start</span><br><span class="line">docker start CONTAINER ID </span><br><span class="line"># 新建并启动</span><br><span class="line">docker run mysql </span><br><span class="line"># 等价于create 和 start ，如果镜像未找到则会从仓库中下载</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除运行时的容器 </span><br><span class="line">docker rm -f CONTAINER ID</span><br><span class="line">docker rm CONTAINER ID</span><br></pre></td></tr></table></figure><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop CONTAINER ID</span><br></pre></td></tr></table></figure><h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart CONTAINER ID</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it CONTAINER ID bash 或 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios同步Promise</title>
      <link href="/793902753.html"/>
      <url>/793902753.html</url>
      
        <content type="html"><![CDATA[<h1 id="Axios地址"><a href="#Axios地址" class="headerlink" title="Axios地址"></a>Axios地址</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.kancloud.cn&#x2F;yunye&#x2F;axios&#x2F;234845</span><br></pre></td></tr></table></figure><h1 id="Promise封装"><a href="#Promise封装" class="headerlink" title="Promise封装"></a>Promise封装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        axios.get(url).then((res) &#x3D;&gt; &#123;</span><br><span class="line">          resolve(res.data);</span><br><span class="line">        &#125;).catch(function (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### 在vue中使用</span><br><span class="line">this.function(url).then(res &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,</span><br><span class="line">error &#x3D;&gt; &#123;</span><br><span class="line">    console.log(error); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器跨域</title>
      <link href="/3234540990.html"/>
      <url>/3234540990.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入创建目录 &#x2F;Users&#x2F;【用户名】&#x2F;Documents</span><br><span class="line">mkdir -p MyChromeDevUserData</span><br><span class="line">&#x2F;&#x2F; 打开浏览器 如果和上方相同则复制即可 用户名改成本机电脑的</span><br><span class="line">open -n &#x2F;Applications&#x2F;Google\ Chrome.app&#x2F; --args --disable-web-security --user-data-dir&#x3D;&#x2F;Users&#x2F;【用户名】&#x2F;Documents&#x2F;MyChromeDevUserData</span><br><span class="line">&#x2F;&#x2F; 头部出现标记即可</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven私服搭建以及使用</title>
      <link href="/3636584195.html"/>
      <url>/3636584195.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>nexus是一个强大的maven仓库管理器,它极大的简化了本地内部仓库的维护和外部仓库的访问.</p><p>nexus是一套开箱即用的系统不需要数据库,它使用文件系统加Lucene来组织数据</p><p>nexus使用ExtJS来开发界面,利用Restlet来提供完整的REST APIs,通过IDEA和Eclipse集成使用</p><p>nexus支持webDAV与LDAP安全身份认证.</p><p>nexus提供了强大的仓库管理功能,构件搜索功能,它基于REST,友好的UI是一个extjs的REST客户端,占用较少的内存,基于简单文件系统而非数据库.</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>节省外网带宽。  </p><p>加速Maven构建。  </p><p>部署第三方构件。  </p><p>提高稳定性，增强控制。  </p><p>降低中央仓库的负荷。</p><p>控制和审计。 </p><p>建立本地内部公用仓库。<br><img alt data-src="/img/maven/16F59AB6-A109-4008-BCA6-89289B9DD456.png" class="lozad"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、先搜索Nexus3、或者到hub.docker.com搜索（基于界面显示有教程）</span><br><span class="line">docker search nexus3</span><br><span class="line">2、拉取镜像</span><br><span class="line">docker pull sonatype/nexus3</span><br><span class="line">3、启动镜像创建容器</span><br><span class="line">（Mac）在本地创建镜像挂载的目录 /usr/local/nexus-data 其次需要在docker配置挂载路径才能运行下面命令</span><br><span class="line">docker run -d -p 8081:8081 --name nexus3 -v /usr/local/nexus-data:/nexus-data --restart=always sonatype/nexus3</span><br><span class="line">注意:即使有错误也能创建成功,可通过docker ps -a查看是否创建错误的通过 docker rm -f 容器ID</span><br></pre></td></tr></tbody></table></figure><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><blockquote><p>Maven私服启动的话大约要一分钟左右,其次我们命令中设置了自启就是说docker关闭重启Maven私服是自己启动的。</p></blockquote><p><img alt data-src="/img/maven/3CC6D686-C20F-45E2-B8A1-362DA3CF7419.png" class="lozad"><br>进入页面之后有个sign in按钮点击登录即可,默认用户名的话是admin。<br>其次如果看到此教程安装的话密码不是其他文章看到的admin123了。<br>密码的话可以在映射文件中查看/usr/local/nexus-data/admin.password,也可以在容器中通过此命令:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id bash</span><br><span class="line">cd nexus-data</span><br><span class="line">cat admin.password</span><br></pre></td></tr></tbody></table></figure><p>登录之后有4个设置步骤重置密码,其他步骤可翻译自行设置。</p><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>登录之后搜索框左侧会有个设置的图标点击进去之后点开repositories。<br><img alt data-src="/img/maven/AEE5D9C4-AD92-48D7-ADFD-2D810C4CAEE0.png" class="lozad"><br>点击Create Repository 选择 maven2（hosted）。<br><img alt data-src="/img/maven/FC789497-A8CF-4670-8019-D96EFEBD55ED.png" class="lozad"><br>创建之后跳转到列表点击自己创建的仓库可看详情，其中url属性是仓库地址到时候在maven中使用。<br><img alt data-src="/img/maven/BAC90E5C-BBAF-4FB9-8F4D-5AF459F30F9B.png" class="lozad">  </p><h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p>设置 -> Security -> Users -> Create local user<br>其次里面创建的时候有角色属性需要设置全选即可。</p><h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmd 运行 mvn -version</span><br><span class="line">Maven home: /usr/local/apache-maven-3.6.0</span><br><span class="line">Java version: 1.8.0_191, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: "mac os x", version: "10.15", arch: "x86_64", family: "mac"</span><br></pre></td></tr></tbody></table></figure><p>Maven home 则是maven路径我们进入目录之后到conf打开settings.xml找到<servers>这个标签。<br><img alt data-src="/img/maven/B4761DFB-D09C-4FF9-AB04-C7305F8B55F3.png" class="lozad"><br>里面的参数就是创建用户时设置的。<br>这里配置好之后创建个两个项目测试一下一个打包一个使用。</servers></p><h2 id="发布Jar到私服"><a href="#发布Jar到私服" class="headerlink" title="发布Jar到私服"></a>发布Jar到私服</h2><p><img alt data-src="/img/maven/30DDE636-D1BC-4370-B139-C71DE9879B76.png" class="lozad"><br>图中方框地方一定要特别注意因为我们创建的仓库是RELEASE版本。<br>发布的Jar可以在http://端口:ip/#browse/search/maven中查看。</p><h2 id="使用打包的Jar"><a href="#使用打包的Jar" class="headerlink" title="使用打包的Jar"></a>使用打包的Jar</h2><p><img alt data-src="/img/maven/592672BF-3731-4888-A6CB-7BE08D2FB110.png" class="lozad"><br>这里我们使用了发布到私服的Jar由于没有指定私服仓库默认是从本地再到中央仓库进行查找，由于发布的时候会克隆到本地所以我先把本地的删除了才出现这效果。</p><pre><code class="text"># 在需要使用jar的项目中的pom配置。# 聪明的人应该想到了下面的私服仓库可以在settings.xml配置这样就不用每次都在项目的pom中写入。 <dependencies>        <dependency>            <groupId>com.animo</groupId>            <artifactId>utils</artifactId>            <version>1.0-RELEASE</version>        </dependency>    </dependencies>    <distributionManagement>        <repository>            <!--此名称要和maven路径中的conf/settings.xml中设置的ID一致 -->            <id>animo</id>            <url>http://localhost:8081/repository/animo-release/</url>        </repository>    </distributionManagement></code></pre><p><img alt data-src="/img/maven/7CE01415-F3E4-4E8B-912E-49CD9BF7A741.png" class="lozad"> </p></body></html>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pi NetWork</title>
      <link href="/3243210231.html"/>
      <url>/3243210231.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>Pi Network是一个国外的手机免费挖矿项目，2019年的7月份传入国内，近期热度是越来越高，多家交易所也已关注，但是目前还属于期货，预计今年年底到明年年初就会有动作，所以还是建议大家不要错过！0投资，有可能赚几十万！</p></blockquote><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><blockquote><p>Pi是由美国斯坦福大学博士团队（这个大学世界排名第二）开发的社交裂变的挖矿，创始人在2009年做了一款社交应用，人数达到了2000多万，创始人也因此获得了创新基金奖，所以来头很大。</p></blockquote><h1 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h1><p>手机用户直接打开链接下载 <a href="https://www.lanzous.com/i7ez8ji" target="_blank" rel="noopener">https://www.lanzous.com/i7ez8ji</a><br>电脑用户用手机扫描下方二维码下载<br><img alt data-src="/img/pi/FBC98980-8C21-4E92-A215-49B8168102D7.png" class="lozad"><br>以上是安卓用户的下载方式，苹果用户需要使用（非大陆地区）的ID才能下载！<br>这边免费提供一个香港的app账号密码！下载后注册步骤与安卓版本一样！<br>账号：<a href="mailto:w591db8f@icloud.com">w591db8f@icloud.com</a> 密码：Aa112211<br>帐号：<a href="mailto:840957322@qq.com">840957322@qq.com</a>密码：Zxbtb123<br>帐号：<a href="mailto:l548lrl5@icloud.com">l548lrl5@icloud.com</a>密码：Ss112211<br>帐号：<a href="mailto:c2ehzt8s@icloud.com">c2ehzt8s@icloud.com</a>密码：Ss112211<br>帐号：<a href="mailto:e9dqvz69@icloud.com">e9dqvz69@icloud.com</a>密码：Ss112211<br>登录账号后，苹果app上直接搜索pi就能找到，下载之后退出账号！<br>启动慢的话是因为外国服务器连接缓慢等等就OK。  </p><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><blockquote><p>这个项目是全英文的，要认真仔细严格按照下面的流程操作，以免出错！  </p></blockquote><p>1、安装好后打开APP，点击“Continue with phone number”（中文意思：手机号注册）。<br><img alt data-src="/img/pi/2C7D18D2-2873-41A2-82A1-1E6E610C1A95.png" class="lozad"><br>2、然后点“小箭头”。<br><img alt data-src="/img/pi/3BD2D84C-19F9-4DF9-89C1-21E2F4F0960A.png" class="lozad"><br>3、找到“China（+86）”。<br><img alt data-src="/img/pi/D32A47D2-B4C5-43F4-AA74-3F10AAD2744F.png" class="lozad"><br>4、然后输入你的手机号码，点“Go”。<br><img alt data-src="/img/pi/5A9B7D91-35A5-4152-A0FD-832770DDF6C8.png" class="lozad"><br>5、然后在Passworld下面的方框里输入登录密码，在Verlfy your password下面的方框里再次输入登录密码，最后点“SUBMIT”。<br>注意：密码要求：字母加数字，字母必须包含大小写，密码不得低于8位<br><img alt data-src="/img/pi/3FED6211-C2E8-4D19-B1FE-2614CBB100E3.png" class="lozad"><br>6、然后在Flrst Name下面的方框输入“名”，在Last Mame下面的方框里输入“姓”，千万不要搞反了，最后在Choose your usemame下面的方框里输入“用户名”。<br>注意：这个用户名可以是纯字母，也可以是字母加数字，而且这个用户名也是你的个人邀请码，在你邀请别人时，让他们填写。<br>最后点“SUBMIT”，如果点了后，没有跳转，说明你的用户名已经有其它人用了，那你重新换个用户名就可以了。<br><img alt data-src="/img/pi/B28C25C0-56C8-484D-8B63-15F7980B1D2A.png" class="lozad"><br>7、在lnvltatlon code下面的方框里输入：Animo，这个是邀请码。<br><img alt data-src="/img/pi/5055B5DE-FAE2-43E5-9AF1-5ED69AC05191.png" class="lozad"><br>8、再根据提示一直点确认，跟着提示下一步，如下图：<br><img alt data-src="/img/pi/0EA8CCA6-9AB4-4D92-9E9C-90C0E11B5737.png" class="lozad"><br>9、完成上面的操作后，说明已经注册成功。直到出现下面这张图：<br><img alt data-src="/img/pi/773C237B-AD0C-42C8-AC4C-745DDA744BE5.png" class="lozad"><br>10、进行“手机号认证”。如下图：<br><img alt data-src="/img/pi/1739BD87-4AEA-4057-ADF8-DE8ADDAFF28A.png" class="lozad"><br>手机无法认证解决方法：手动输入接收号码：0016508220314，再把验证码发送出去。<br>11、然后就会自动挖矿，每天可以挖12个多币。需要注意的是：24小时后，会停止挖矿。需要手动点击挖矿页面的“闪电标志”重新开启挖矿，才会继续挖币，也就是每隔24小时都要手动点闪电标志开启下挖矿。<br><img alt data-src="/img/pi/ECF942A4-D0C9-4AE3-A30E-0489574A10C6.png" class="lozad">  </p><h1 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h1><p>1、一个手机登录一号，不要换号登录，有防刷机制，容易封号。</p><p>2、在pfofile（文件）页面，就是看自己姓名和邀请码的页面，最下面有个 SIGN OUT 点击后，就是退出APP，不要乱点，手机没验证的话，点这个退出，会造成挖的币全部消失！</p><p>那么挖的币怎么交易，值多少钱？  </p><p>答：明年Pi会上全球交易所，所以现在先尽情的挖，去屯币吧！预计明年3月14日上交易所交易。  </p><p>就说大家都知道的比特币吧，2009年比特币刚出来的时候，每天都可以免费挖几个，按现在的价格就是每天可以挖几十万元人民币。而且我要告诉大家的是，这个和比特币一样，是真正的区块链，不是资金盘，不需要投资，完全免费挖币，人人都一样。<br>比特币是国外人搞的，这个币也是国外人搞的，所以你懂的！零投资，零损失，每天花10秒点一下，或许将获得一份意想不到的财富！</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataElasticSearch</title>
      <link href="/4129204835.html"/>
      <url>/4129204835.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>Spring Data Elasticsearch项目提供与Elasticsearch搜索引擎的集成。Spring Data Elasticsearch的关键功能领域是一个以POJO为中心的模型，用于与Elastichsearch文档交互并轻松编写存储库风格的数据访问层。</p></blockquote><h1 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h1><table><thead><tr><th align="center">名称</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">spring-boot-starter-parent</td><td align="center">2.2.0.RELEASE</td></tr><tr><td align="center">spring-boot-starter-data-elasticsearch</td><td align="center">2.2.0.RELEASE</td></tr><tr><td align="center">spring-data-elasticsearch</td><td align="center">3.2.0.RELEASE</td></tr><tr><td align="center">elasticsearch-rest-high-level-client</td><td align="center">6.8.3</td></tr></tbody></table><h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><h2 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><dependencies></span><br><span class="line">       <dependency></span><br><span class="line">           <groupId>org.springframework.boot</groupId></span><br><span class="line">           <artifactId>spring-boot-starter-data-elasticsearch</artifactId></span><br><span class="line">       </dependency></span><br><span class="line">       <dependency></span><br><span class="line">           <groupId>org.springframework.boot</groupId></span><br><span class="line">           <artifactId>spring-boot-starter-web</artifactId></span><br><span class="line">       </dependency></span><br><span class="line">       <dependency></span><br><span class="line">           <groupId>org.projectlombok</groupId></span><br><span class="line">           <artifactId>lombok</artifactId></span><br><span class="line">       </dependency></span><br><span class="line">       <dependency></span><br><span class="line">           <groupId>org.springframework.boot</groupId></span><br><span class="line">           <artifactId>spring-boot-starter-test</artifactId></span><br><span class="line">           <scope>test</scope></span><br><span class="line">           <exclusions></span><br><span class="line">               <exclusion></span><br><span class="line">                   <groupId>org.junit.vintage</groupId></span><br><span class="line">                   <artifactId>junit-vintage-engine</artifactId></span><br><span class="line">               </exclusion></span><br><span class="line">           </exclusions></span><br><span class="line">       </dependency></span><br><span class="line">   </dependencies></span><br></pre></td></tr></tbody></table></figure><h2 id="Yml"><a href="#Yml" class="headerlink" title="Yml"></a>Yml</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 用逗号隔开配置多个</span><br><span class="line">es:</span><br><span class="line">  connecteds: "localhost:9200,"</span><br></pre></td></tr></tbody></table></figure><h2 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = "es")</span><br><span class="line">@Component</span><br><span class="line">@Data</span><br><span class="line">public class EsConfigBean {</span><br><span class="line">    private String connecteds;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ElasticConnectedConfig extends AbstractElasticsearchConfiguration {</span><br><span class="line">    @Autowired</span><br><span class="line">    EsConfigBean esConfigBean;</span><br><span class="line">    @Override</span><br><span class="line">    public RestHighLevelClient elasticsearchClient() {</span><br><span class="line">        ClientConfiguration clientConfiguration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(esConfigBean.getConnecteds().split(","))</span><br><span class="line">                .build();</span><br><span class="line">        return RestClients.create(clientConfiguration).rest();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h1><h2 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h2><p>应用于字段级别以标记用于标识目的的字段。</p><h2 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h2><p>在类级应用，以指示该类是映射到数据库的候选类</p><ul><li>indexName 索引库名称</li><li>type 映射类型,如果未设置则使用小写类名</li><li>shards 分片数</li><li>replicas 副本数</li><li>refreshIntervall 索引刷新间隔时间 默认1s</li><li>indexStoreType 索引存储类型 默认fs</li><li>createIndex 是否创建索引库</li><li>versionType 配置管理版本 默认外部</li></ul><h2 id="Field"><a href="#Field" class="headerlink" title="@Field"></a>@Field</h2><p>在字段应用，设置该字段的映射属性</p><ul><li>name 对应ES的索引库映射名称 默认为java字段名</li><li>type Text, Integer, Long, Date, Float, Double, Boolean, Object, Auto, Nested, Ip, Attachment, Keyword.</li><li>format 定义日期的格式以及和pattern组合使用的自定义格式</li><li>store 标记原字段值是否应该存储在ES中，默认值为false。</li><li>analyzer 字段内容分词</li><li>searchAnalyzer 搜索内容分词</li><li>normalizer 自定义规格化器</li><li>copy_to 将多个文档字段复制到的目标字段。</li></ul><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 索引名称不能包含大写</span><br><span class="line">*/</span><br><span class="line">@Data</span><br><span class="line">@Document(indexName = "es_mk",type = "mk",shards = 1,replicas = 0)</span><br><span class="line">public class EsMk {</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    /**</span><br><span class="line">     * 标题字段</span><br><span class="line">     * name字段数据使用ik_max_word分析（细粒度）</span><br><span class="line">     * 搜索的时候使用ik_smart（粗粒度）</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Text,analyzer = "ik_max_word",searchAnalyzer = "ik_smart")</span><br><span class="line">    private String name;</span><br><span class="line">    /**</span><br><span class="line">     * 描述字段</span><br><span class="line">     * 同上面标题字段</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Text,analyzer = "ik_max_word",searchAnalyzer = "ik_smart")</span><br><span class="line">    private String description;</span><br><span class="line">    /**</span><br><span class="line">     * 编号字段</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private Integer number;</span><br><span class="line">    /**</span><br><span class="line">     * 价格</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Float)</span><br><span class="line">    private Float price;</span><br><span class="line">    /**</span><br><span class="line">     * 旧价格</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Float)</span><br><span class="line">    private Float oldPrice;</span><br><span class="line">    /***</span><br><span class="line">     * 新增时间 自定义</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Date,format = DateFormat.custom,pattern = "yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis")</span><br><span class="line">    private Date createdTime;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>由于亲测编写JavaBean直接启动并不能创建索引库和映射需要编写该Bean对应的Repository。<br>底层通过ElasticSearchTemplate和ElasticSearchRestTemplate操作Es。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public interface EsMkRepository extends ElasticsearchRepository<EsMk,String> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/es/39E65976-E874-445D-8720-9CA2788F4FA2.png" class="lozad"><br><img alt data-src="/img/es/A2072895-A9C8-4789-ABF6-6A335E802FE1.png" class="lozad"></p><h1 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h1><h2 id="保存OR更新"><a href="#保存OR更新" class="headerlink" title="保存OR更新"></a>保存OR更新</h2><p>我们操作都基于Repository所以要引入相对于的索引库的Repository，保存和更新都使用Save需要主键。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># save方法存在即更新基于ID主键,反之保存。</span><br><span class="line"> @Test</span><br><span class="line">    public void save(){</span><br><span class="line">        EsMk esMk = new EsMk();</span><br><span class="line">        esMk.setName("Springboot 微信小程序 – 微信登录功能实战");</span><br><span class="line">        esMk.setDescription("简介：通过学习本课程可以掌握如何使用微信api，如何使用httpClient工具跨服务器调用微信url，掌握如何解析string到自己封装的model，掌握自定义会话保存至redis");</span><br><span class="line">        esMk.setNumber(1059);</span><br><span class="line">        esMk.setPrice(0.00F);</span><br><span class="line">        esMk.setOldPrice(0.00F);</span><br><span class="line">        esMk.setId(System.currentTimeMillis()+"");</span><br><span class="line">        esMk.setCreatedTime(new Date());</span><br><span class="line">        esMkRepository.save(esMk);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="TermQuery"><a href="#TermQuery" class="headerlink" title="TermQuery"></a>TermQuery</h2><h3 id="单字段查询"><a href="#单字段查询" class="headerlink" title="单字段查询"></a>单字段查询</h3><p>TermQuery查询不会进行分词,在IK分词的时候默认会把大写转换成小写。所以我们库里存的是SpringBoot，但是搜索如果使用SpringBoot的话是搜索不到的必须全部小写。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Json</span><br><span class="line">{</span><br><span class="line">    "query" : {</span><br><span class="line">        "term" : { "name" : "springboot" }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"># Java</span><br><span class="line">TermQueryBuilder termQueryBuilder = new TermQueryBuilder("name","springboot");</span><br><span class="line">NativeSearchQuery nativeSearchQuery = new NativeSearchQuery(termQueryBuilder);</span><br><span class="line">Page<EsMk> page = esMkRepository.search(nativeSearchQuery);</span><br></pre></td></tr></tbody></table></figure><h3 id="source过滤"><a href="#source过滤" class="headerlink" title="_source过滤"></a>_source过滤</h3><p>通过_source字段名称过滤显示的字段值。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Json</span><br><span class="line">{</span><br><span class="line">    "query" : {</span><br><span class="line">        "term" : { "name" : "springboot" }</span><br><span class="line">    },</span><br><span class="line">    "_source":["name","description"]</span><br><span class="line">}</span><br><span class="line"># Java</span><br><span class="line">//精确查询不分词</span><br><span class="line">TermQueryBuilder termQueryBuilder = new TermQueryBuilder("name","springboot");</span><br><span class="line">NativeSearchQuery nativeSearchQuery = new NativeSearchQuery(termQueryBuilder);</span><br><span class="line">//需要显示的字段</span><br><span class="line">String[] includes = {"name","description","price"};</span><br><span class="line">FetchSourceFilter fetchSourceFilter = new FetchSourceFilter(includes,null);</span><br><span class="line">nativeSearchQuery.addSourceFilter(fetchSourceFilter);</span><br><span class="line">Page<EsMk> page = esMkRepository.search(nativeSearchQuery);</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Es安装IK分词器</title>
      <link href="/2655640536.html"/>
      <url>/2655640536.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/medcl/elasticsearch-analysis-ik</span><br><span class="line"></span><br><span class="line">cd elasticsearch-analysis-ik</span><br><span class="line"># http访问Es端口即可看到Es版本号 version - number</span><br><span class="line"># git checkout tags/v6.8.4</span><br><span class="line">git checkout tags/{version} </span><br><span class="line"></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line">mvn compile</span><br><span class="line"></span><br><span class="line">mvn package</span><br></pre></td></tr></tbody></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>进入打包好的ik目录下的/target/releases/elasticsearch-analysis-ik-*.zip解压缩到es/plugins,然后重新启动es。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Caused-by-java-nio-file-FileSystemException-usr-share-elasticsearch-plugins-DS-Store-plugin-descriptor-properties-Not-a-directory"><a href="#Caused-by-java-nio-file-FileSystemException-usr-share-elasticsearch-plugins-DS-Store-plugin-descriptor-properties-Not-a-directory" class="headerlink" title="Caused by: java.nio.file.FileSystemException: /usr/share/elasticsearch/plugins/.DS_Store/plugin-descriptor.properties: Not a directory"></a>Caused by: java.nio.file.FileSystemException: /usr/share/elasticsearch/plugins/.DS_Store/plugin-descriptor.properties: Not a directory</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.nio.file.FileSystemException: /usr/share/elasticsearch/plugins/.DS_Store/plugin-descriptor.properties: Not a directory</span><br><span class="line">at sun.nio.fs.UnixException.translateToIOException(UnixException.java:100) ~[?:?]</span><br><span class="line">at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111) ~[?:?]</span><br><span class="line">at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116) ~[?:?]</span><br><span class="line">at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:219) ~[?:?]</span><br><span class="line">at java.nio.file.Files.newByteChannel(Files.java:374) ~[?:?]</span><br><span class="line">at java.nio.file.Files.newByteChannel(Files.java:425) ~[?:?]</span><br><span class="line">at java.nio.file.spi.FileSystemProvider.newInputStream(FileSystemProvider.java:420) ~[?:?]</span><br><span class="line">at java.nio.file.Files.newInputStream(Files.java:159) ~[?:?]</span><br><span class="line">at org.elasticsearch.plugins.PluginInfo.readFromProperties(PluginInfo.java:162) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.readPluginBundle(PluginsService.java:398) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.findBundles(PluginsService.java:386) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.getPluginBundles(PluginsService.java:379) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.<init>(PluginsService.java:151) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.node.Node.<init>(Node.java:339) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.node.Node.<init>(Node.java:266) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap$5.<init>(Bootstrap.java:212) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:212) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:333) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:159) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">... 6 more</span><br></pre></td></tr></tbody></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由于使用MacBook在es/plugins目录下解压的IK分词器导致会自动创建.DS_Store从而让Es启动失败。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>如果出现上述问题的话需要删除plugins重新创建其次在外部解压好之后再放入。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除当前下的所有.DS_Store</span><br><span class="line">find ./ -name ".DS_Store" -depth -exec rm {} \;</span><br></pre></td></tr></tbody></table></figure><h2 id="Caused-by-java-lang-IllegalArgumentException-Plugin-analysis-ik-was-built-for-Elasticsearch-version-6-5-0-but-version-6-8-4-is-running"><a href="#Caused-by-java-lang-IllegalArgumentException-Plugin-analysis-ik-was-built-for-Elasticsearch-version-6-5-0-but-version-6-8-4-is-running" class="headerlink" title="Caused by: java.lang.IllegalArgumentException: Plugin [analysis-ik] was built for Elasticsearch version 6.5.0 but version 6.8.4 is running"></a>Caused by: java.lang.IllegalArgumentException: Plugin [analysis-ik] was built for Elasticsearch version 6.5.0 but version 6.8.4 is running</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Plugin [analysis-ik] was built for Elasticsearch version 6.5.0 but version 6.8.4 is running</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.verifyCompatibility(PluginsService.java:346) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.loadBundle(PluginsService.java:531) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.loadBundles(PluginsService.java:471) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.plugins.PluginsService.<init>(PluginsService.java:163) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.node.Node.<init>(Node.java:339) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.node.Node.<init>(Node.java:266) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap$5.<init>(Bootstrap.java:212) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:212) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:333) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:159) ~[elasticsearch-6.8.4.jar:6.8.4]</span><br><span class="line">... 6 more</span><br></pre></td></tr></tbody></table></figure><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>虽然下载的时候指定了分支为6.8.4版本与之Es对应但是打包之后是6.5.0。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>修改ik目录下的pom.xml文件,修改elasticsearch.version的版本为当前Es版本。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="默认分词器"><a href="#默认分词器" class="headerlink" title="默认分词器"></a>默认分词器</h2><p>默认分词器对中文会分成单个词组。<br><img alt data-src="/img/es/8C1EDB43-CB90-4071-BDE7-8F61C536B319.png" class="lozad"></p><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><h3 id="ik-max-word"><a href="#ik-max-word" class="headerlink" title="ik_max_word"></a>ik_max_word</h3><p>会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合，适合 Term Query；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "text": "中华人民共和国国歌","analyzer":"ik_max_word"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/es/82AB795C-4753-461F-934F-30A1508C103A.png" class="lozad"></p><h3 id="ik-smart"><a href="#ik-smart" class="headerlink" title="ik_smart"></a>ik_smart</h3><p>会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase 查询。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "text": "中华人民共和国国歌","analyzer":"ik_smart"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/es/A7CBA58D-EE63-4CFB-983B-AA73085C4D49.png" class="lozad"></p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="静态字典"><a href="#静态字典" class="headerlink" title="静态字典"></a>静态字典</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 未使用静态字典（自定义本地字典）</span><br><span class="line">{</span><br><span class="line">    "text": "慕课网","analyzer":"ik_smart"</span><br><span class="line">} </span><br><span class="line">or</span><br><span class="line">{</span><br><span class="line">    "text": "慕课网","analyzer":"ik_max_word"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/es/4FF18E55-5549-427C-8349-0333C17366D9.png" class="lozad"><br><img alt data-src="/img/es/1AC1D0A4-54C7-4565-BCA7-EB644C9007B9.png" class="lozad"><br>在ik/config目录（也可以其他目录）下创建一个自定义的字典这里我命名为static.dic。<br>修改config下的IKAnalyzer.cfg.xml如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><?xml version="1.0" encoding="UTF-8"?></span><br><span class="line"><!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"></span><br><span class="line"><properties></span><br><span class="line"><comment>IK Analyzer 扩展配置</comment></span><br><span class="line"><!--用户可以在这里配置自己的扩展字典 --></span><br><span class="line"><entry key="ext_dict">static.dic</entry></span><br><span class="line"> <!--用户可以在这里配置自己的扩展停止词字典--></span><br><span class="line"><entry key="ext_stopwords"></entry></span><br><span class="line"><!--用户可以在这里配置远程扩展字典 --></span><br><span class="line"><!-- <entry key="remote_ext_dict">words_location</entry> --></span><br><span class="line"><!--用户可以在这里配置远程扩展停止词字典--></span><br><span class="line"><!-- <entry key="remote_ext_stopwords">words_location</entry> --></span><br><span class="line"></properties></span><br></pre></td></tr></tbody></table></figure><p>修改完之后重启Es然后在测试之前数据的效果。<br><img alt data-src="/img/es/AD2799D0-9E65-4AED-8882-F332F20EC484.png" class="lozad"><br><img alt data-src="/img/es/DAEFA1E6-83A1-4818-9DB1-3412F23D4AC3.png" class="lozad"></p><h2 id="动态字典"><a href="#动态字典" class="headerlink" title="动态字典"></a>动态字典</h2></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Docker</title>
      <link href="/2531904154.html"/>
      <url>/2531904154.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><h1 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h1><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS版本是否支持 Docker 。可以通过 uname -r 命令查看你当前的内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h1 id="yum更新"><a href="#yum更新" class="headerlink" title="yum更新"></a>yum更新</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 切换root权限登录CentOS</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure><h1 id="卸载旧版"><a href="#卸载旧版" class="headerlink" title="卸载旧版"></a>卸载旧版</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果安装过旧版</span><br><span class="line">sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><h1 id="依赖软件包"><a href="#依赖软件包" class="headerlink" title="依赖软件包"></a>依赖软件包</h1><p>yum-util提供yum-config-manager,另外两个是devicemapper的依赖包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h1 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyum.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查询Docker版本</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line"># 例如：sudo yum install docker-ce-18.03.1.ce</span><br><span class="line">sudo yum install &lt;FQPN&gt;</span><br><span class="line"></span><br><span class="line"># 加入开机自启</span><br><span class="line">sudo systemctl start dockersudo systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h1 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h1><p>网易镜像中心：<a href="https://c.163.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163.com/hub#/m/home/</a><br>daocloud镜像市场：<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">https://hub.daocloud.io/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不同CentOS启动方式不一样自选</span><br><span class="line">systemctl restart docker.service</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h2 id="网易镜像"><a href="#网易镜像" class="headerlink" title="网易镜像"></a>网易镜像</h2><p>创建/修改,/etc/docker/daemon.json。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;] </span><br><span class="line">&#125;</span><br><span class="line">#修改之后重启</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><h2 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h2><p>创建/修改,/etc/docker/daemon.json。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;ef017c13.m.daocloud.io&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"># 修改之后重启</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><h2 id="命令添加"><a href="#命令添加" class="headerlink" title="命令添加"></a>命令添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io</span><br><span class="line">#修改之后重启</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h1 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行命令</span><br><span class="line">docker info </span><br><span class="line">#文件位置</span><br><span class="line">Docker Root Dir:&#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装ElasticSearch</title>
      <link href="/704538247.html"/>
      <url>/704538247.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p></blockquote><h1 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h1><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br><a href="https://hub.docker.com/_/elasticsearch" target="_blank" rel="noopener">https://hub.docker.com/_/elasticsearch</a></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#这里不写版本拉取最新版</span><br><span class="line">docker pull elasticsearch </span><br><span class="line">Error response from daemon: manifest for elasticsearch:latest not found</span><br><span class="line"># 未找到最新版本这里我们需要手动指定版本了</span><br><span class="line">docker pull elasticsearch:6.8.4</span><br></pre></td></tr></tbody></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时容器</span><br><span class="line">docker run -d --name tempelasticsearch elasticsearch:6.8.4 </span><br><span class="line"># 拉取配置到本地宿主机映射 到后面可以在本地多复制几份</span><br><span class="line">sudo docker cp tempelasticsearch:/usr/share/elasticsearch /usr/local/elasticsearch1</span><br><span class="line"># 删除临时容器</span><br><span class="line">docker rm -f tempelasticsearch</span><br><span class="line"># 创建容器 这里会出现拒绝挂载 具体操作在本博的Nginx 其次不能直接设置/usr/local为挂载目录这是docker保留的 但是可以设置子目录</span><br><span class="line">docker run -d --name elasticsearch1 -p 9200:9200 -p 9300:9300 -v /usr/local/elasticsearch1:/usr/share/elasticsearch elasticsearch:6.8.4</span><br></pre></td></tr></tbody></table></figure><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>创建容器之后运行 docker start elasticsearch1 之后 docker ps 未发现容器启动。<br>通过docker logs –since 30m elasticsearch1 查看日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.nio.file.AccessDeniedException: /usr/share/elasticsearch/config/jvm.options</span><br></pre></td></tr></tbody></table></figure><p>这里由于和宿主机挂载导致读取不到jvm.options通过在宿主机给挂载文件加权限</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/elasticsearch1</span><br></pre></td></tr></tbody></table></figure><p>之后可通过docker ps 查看elasticsearch已运行通过访问localhost:9200可校验是否成功（启动慢）<br><img alt data-src="/img/docker/4599337E-766E-4760-A003-C3AFFBFC5DD0.png" class="lozad"></p><h1 id="安装ElasticSearch-Head"><a href="#安装ElasticSearch-Head" class="headerlink" title="安装ElasticSearch-Head"></a>安装ElasticSearch-Head</h1><p><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p><h2 id="Node安装"><a href="#Node安装" class="headerlink" title="Node安装"></a>Node安装</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br><span class="line">npm run start</span><br><span class="line">open http://localhost:9100/</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mobz/elasticsearch-head:5-alpine</span><br><span class="line">docker run -p 9100:9100 mobz/elasticsearch-head:5-alpine</span><br></pre></td></tr></tbody></table></figure><h2 id="连接ElasticSearch"><a href="#连接ElasticSearch" class="headerlink" title="连接ElasticSearch"></a>连接ElasticSearch</h2><p>通过访问ElasticSearch-Head（ <a href="http://localhost:9100" target="_blank" rel="noopener">http://localhost:9100</a> ）连接 <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a><br><img alt data-src="/img/docker/5F1A9A3E-084B-4549-A529-099FC64BC497.png" class="lozad"><br>可以发现这里跨域访问被拦截了,我们需要修改端口为9200的config/elasticearch.yml直接宿主机上修改。elasticearch.yml配置如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: "docker-cluster"</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">#跨域访问允许的域名地址</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">#(允许所有域名)以上使 用正则 </span><br><span class="line">http.cors.allow-origin: /.*/</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/docker/604857F7-9652-4CAD-AD2F-96B263088CDF.png" class="lozad"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot使用FastDFS</title>
      <link href="/1017755147.html"/>
      <url>/1017755147.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><ul><li>初始化ClientGlobal配置基本连接信息</li><li>获取TrackerClient客户端</li><li>TrackerClient打开连接获取TrackerServer</li><li>TrackerClient获取StorageServer服务端需要TrackerServer参数</li><li>获取StorageClient1(TrackerServer,StorageServer)</li><li>所有基本操作都基于StorageClient1进行</li></ul><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><h2 id="配置代码"><a href="#配置代码" class="headerlink" title="配置代码"></a>配置代码</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件名称:application.yml</span><br><span class="line">fastdfs:</span><br><span class="line">  connect_timeout_in_seconds: 5</span><br><span class="line">  network_timeout_in_seconds: 30</span><br><span class="line">  charset: utf-8</span><br><span class="line">  tracker_servers: 192.168.168.231:22122</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">文件名称:FastDFSBean</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = "fastdfs")</span><br><span class="line">@Data</span><br><span class="line">public class FastDFSBean {</span><br><span class="line">    private int connectTimeoutInSeconds;</span><br><span class="line">    private int networkTimeoutInSeconds;</span><br><span class="line">    private String charset;</span><br><span class="line">    private String trackerServers;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">文件名称:FastDFSConfig</span><br><span class="line">@Component</span><br><span class="line">@Order(1)</span><br><span class="line">public class FastDFSConfig implements ApplicationRunner {</span><br><span class="line">    @Autowired</span><br><span class="line">    private FastDFSBean fastDFSBean;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception {</span><br><span class="line">        ClientGlobal.setG_connect_timeout(fastDFSBean.getConnectTimeoutInSeconds());</span><br><span class="line">        ClientGlobal.setG_network_timeout(fastDFSBean.getNetworkTimeoutInSeconds());</span><br><span class="line">        ClientGlobal.setG_charset(fastDFSBean.getCharset());</span><br><span class="line">        try {</span><br><span class="line">            ClientGlobal.initByTrackers(fastDFSBean.getTrackerServers());</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } catch (MyException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println("fastDFS配置成功");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="公用私有方法"><a href="#公用私有方法" class="headerlink" title="公用私有方法"></a>公用私有方法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 最终操作都基于StorageClient1 所以封装获取StorageClient1的方法</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private StorageClient1 getStorageClient1(){</span><br><span class="line">    try {</span><br><span class="line">        //创建Tracker客户端</span><br><span class="line">        TrackerClient trackerClient = new TrackerClient();</span><br><span class="line">        //获取Tracker服务端</span><br><span class="line">        TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line">        //创建Storage服务端</span><br><span class="line">        StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);</span><br><span class="line">        //创建Storage客户端</span><br><span class="line">        StorageClient1 storageClient1 = new StorageClient1(trackerServer,storageServer);</span><br><span class="line">        return storageClient1;</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println("链接出错");</span><br><span class="line">    }</span><br><span class="line">    return null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String upload(MultipartFile file){</span><br><span class="line">    StorageClient1 storageClient1 = getStorageClient1();</span><br><span class="line">    try {</span><br><span class="line">        //文件字节</span><br><span class="line">        byte[] bytes = file.getBytes();</span><br><span class="line">        //文件原始名称</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        //获取扩展名称</span><br><span class="line">        String file_ext_name = originalFilename.substring(originalFilename.lastIndexOf(".") + 1);</span><br><span class="line">        String fileId = storageClient1.upload_file1(bytes,file_ext_name,null);</span><br><span class="line">        System.out.println("文件ID:"+fileId);</span><br><span class="line">        return fileId;</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } catch (MyException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    return null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类专用</span><br><span class="line"> * 由于测试代码无法使用MultipartFile 所以这个测试专用</span><br><span class="line"> * @param local_filename 文件全路径</span><br><span class="line"> * @param file_ext_name 文件扩展名</span><br><span class="line"> * @param meta_list 源文件信息 可以为Null</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public String uploadTest(String local_filename, String file_ext_name, NameValuePair[] meta_list){</span><br><span class="line">    StorageClient1 storageClient1 = getStorageClient1();</span><br><span class="line">    try {</span><br><span class="line">        String fileId = storageClient1.upload_file1(local_filename, file_ext_name, meta_list);</span><br><span class="line">        System.out.println("文件ID:"+fileId);</span><br><span class="line">        return fileId;</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } catch (MyException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    return null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件下载</span><br><span class="line"> * @param fileId 文件ID</span><br><span class="line"> * @param pathUrl 需要下载到哪个路径</span><br><span class="line"> */</span><br><span class="line">public void download(String fileId,String pathUrl){</span><br><span class="line">    StorageClient1 storageClient1 = getStorageClient1();</span><br><span class="line">    FileOutputStream fileOutputStream = null;</span><br><span class="line">    try {</span><br><span class="line">        byte[] bytes = storageClient1.download_file1(fileId);</span><br><span class="line">        fileOutputStream = new FileOutputStream(new File(pathUrl));</span><br><span class="line">        fileOutputStream.write(bytes);</span><br><span class="line">        System.out.println("写入成功，文件路径:"+pathUrl);</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } catch (MyException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }finally {</span><br><span class="line">        try {</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除文件</span><br><span class="line"> * @param fileId 文件ID</span><br><span class="line"> */</span><br><span class="line">public void delete(String fileId){</span><br><span class="line">    StorageClient1 storageClient1 = getStorageClient1();</span><br><span class="line">    try {</span><br><span class="line">        int result = storageClient1.delete_file1(fileId);</span><br><span class="line">        System.out.println("删除结果反馈:"+result);</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } catch (MyException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping("/fastdfs")</span><br><span class="line">public class FastDFSController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private FastDFSService fastDFSService;</span><br><span class="line">    @GetMapping("/upload")</span><br><span class="line">    public String upload(@RequestParam("file") MultipartFile file){</span><br><span class="line">        return fastDFSService.upload(file);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><h2 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h2><p><img alt data-src="/img/SpringBoot/E333895B-E268-415C-9FC6-656175CF1EC1.png" class="lozad"><br><img alt data-src="/img/SpringBoot/2EF50B7D-0FF3-44C0-847C-7F6A03999FEA.png" class="lozad"></p><h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p><img alt data-src="/img/SpringBoot/DF3DEF51-FA18-451D-A543-58227B6D1B35.png" class="lozad"><br><img alt data-src="/img/SpringBoot/8EBB68EC-0CEF-46AA-A876-5514F321DAEA.png" class="lozad"></p><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p><img alt data-src="/img/SpringBoot/8E9E69D7-C6FB-4D85-B761-2EFC7A81A8F0.png" class="lozad"><br><img alt data-src="/img/SpringBoot/12792CD5-EB04-44EE-8E76-70C9027EC3B0.png" class="lozad"><br><img alt data-src="/img/SpringBoot/1376C271-5DBB-4491-B5F6-58E6497AAE10.png" class="lozad">  </p><h3 id="删除文件-1"><a href="#删除文件-1" class="headerlink" title="删除文件"></a>删除文件</h3><p><img alt data-src="/img/SpringBoot/8306AA97-5F1E-427B-A52D-9F8C68627222.png" class="lozad"><br><img alt data-src="/img/SpringBoot/612BB459-11C7-4B12-B26D-D324CAAC2FDD.png" class="lozad"><br><img alt data-src="/img/SpringBoot/4ED100E7-54A4-414B-A193-569926E86DD5.png" class="lozad">  </p><blockquote><p>该项目代码只作为测试代码,如需使用还得按需修改、调整。项目地址:<a href="https://github.com/LJYYAnimo/SpringBoot-Example/tree/master/SpringBoot-FastDFS" target="_blank" rel="noopener">https://github.com/LJYYAnimo/SpringBoot-Example/tree/master/SpringBoot-FastDFS</a></p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS Storage安装单机测试</title>
      <link href="/193485053.html"/>
      <url>/193485053.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Storage配置"><a href="#Storage配置" class="headerlink" title="Storage配置"></a>Storage配置</h1><p>在另一台Liunx上安装Storage是，需要在此步骤之前需要搭建环境（重复步骤1-8）具体参考本站FastDFS-Tracker安装。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">文件位置:/etc/fdfs/storage.conf</span><br><span class="line">端口:port=23000  # storage服务端口（默认23000,一般不修改）</span><br><span class="line">组名:group_name=group1</span><br><span class="line">向tracker发送心跳间隔时间:heart_beat_interval=30</span><br><span class="line">storage基础目录:base_path=/home/fastdfs  # 数据和日志文件存储根目录</span><br><span class="line">磁盘存储目录（文件存储）:store_path0=/home/fastdfs/fdfs_storage  # 第一个存储目录</span><br><span class="line">多个目录换行加 store_path1=xxx store_path2=xxx</span><br><span class="line">上报tracker地址:tracker_server=192.168.168.231:22122  # tracker服务器IP和端口</span><br><span class="line">多个地址换行加 tracker_server=ip:port</span><br><span class="line">http.server_port=8888  # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)</span><br></pre></td></tr></tbody></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#方式一关闭防火墙（两个服务有需要关闭）</span><br><span class="line">systemctl stop firewalld.service #关闭</span><br><span class="line"></span><br><span class="line">#方式二在防火墙中打开跟踪端口</span><br><span class="line">#在tracker服务器</span><br><span class="line">    vi /etc/sysconfig/iptables</span><br><span class="line">    添加如下端口行：</span><br><span class="line">    -A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT</span><br><span class="line">重启防火墙：</span><br><span class="line">    # service iptables restart</span><br><span class="line"></span><br><span class="line">#在storage服务器</span><br><span class="line">    vi /etc/sysconfig/iptables</span><br><span class="line">    添加如下端口行：</span><br><span class="line">    -A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT</span><br><span class="line">重启防火墙：</span><br><span class="line">    # service iptables restart</span><br></pre></td></tr></tbody></table></figure><h2 id="Tracker启动"><a href="#Tracker启动" class="headerlink" title="Tracker启动"></a>Tracker启动</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/fdfs_trackerd start #启动tracker服务</span><br><span class="line">/etc/init.d/fdfs_trackerd restart #重启动tracker服务</span><br><span class="line">/etc/init.d/fdfs_trackerd stop #停止tracker服务</span><br><span class="line">chkconfig fdfs_trackerd on #自启动tracker服务</span><br></pre></td></tr></tbody></table></figure><p>初次启动成功后会在Tracker基础目录（base_path）中创建logs和data目录。<br><img alt data-src="/img/fastdfs/97061A09-18B9-4616-947D-2606063BB83E.png" class="lozad"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过名称查看是否启动成功:netstat -unltp|grep fdfs</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/3200023D-B687-4BC1-98E5-BCADDF064A03.png" class="lozad"></p><h2 id="Storage启动"><a href="#Storage启动" class="headerlink" title="Storage启动"></a>Storage启动</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/fdfs_storaged start #启动storage服务</span><br><span class="line">/etc/init.d/fdfs_storaged restart #重动storage服务</span><br><span class="line">/etc/init.d/fdfs_storaged stop #停止动storage服务</span><br><span class="line">chkconfig fdfs_storaged on #自启动storage服务</span><br></pre></td></tr></tbody></table></figure><p>剩余操作和上方Tracker一致。</p><h2 id="通信检测"><a href="#通信检测" class="headerlink" title="通信检测"></a>通信检测</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/521C342A-0730-4722-A78F-C06544FD8FF3.png" class="lozad"></p><h1 id="上传测试"><a href="#上传测试" class="headerlink" title="上传测试"></a>上传测试</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件位置:/etc/fdfs/client.conf</span><br><span class="line">base_path=/home/fastdfs</span><br><span class="line">tracker_server=192.168.168.231:22122    #tracker服务器IP和端口</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试命令</span><br><span class="line">fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz</span><br><span class="line">（第二个地址为测试的文件地址可自行通过xftp上传图片之后填写图片路径）</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/9EF2F8F5-539A-4684-9D0F-248A296F5AD3.png" class="lozad"></p><h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件位置:/etc/fdfs/mod_fastdfs.conf</span><br><span class="line">tracker_server=192.168.168.231:22122  #tracker服务器IP和端口</span><br><span class="line">url_have_group_name=true</span><br><span class="line">store_path0=/home/fastdfs/fdfs_storage （如多个则配置path1、path2）</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件位置:/usr/local/nginx/conf/nginx.conf</span><br><span class="line">server {</span><br><span class="line">    listen       8888;    ## 该端口为storage.conf中的http.server_port相同</span><br><span class="line">    location ~/group[0-9]/ {</span><br><span class="line">        ngx_fastdfs_module;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改之后</span><br><span class="line">nginx -s reload #重启nginx || /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></tbody></table></figure><p>这这是测试命令中返回的文件ID</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.168.231:8888/group1/M00/00/00/wKio6F25Sj-Ab6Z9AA-itrfn0m4.tar.gz</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/528E38CE-6C0D-4677-9FC1-83ACCC683330.png" class="lozad"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 文件服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS Tracker安装</title>
      <link href="/537298633.html"/>
      <url>/537298633.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><table><thead><tr><th align="center">Key</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">操作系统</td><td align="center">CentOS 7.X</td></tr><tr><td align="center">远程连接</td><td align="center">Xshell</td></tr><tr><td align="center">文件传输</td><td align="center">Xftp</td></tr><tr><td align="center">Tracker Server</td><td align="center">192.168.168.231</td></tr><tr><td align="center">Storage Server</td><td align="center">192.168.168.232</td></tr></tbody></table><h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/7020E032-E233-4967-B750-28087C21721E.png" class="lozad"></p><h1 id="磁盘目录"><a href="#磁盘目录" class="headerlink" title="磁盘目录"></a>磁盘目录</h1><table><thead><tr><th align="center">Key</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">所有安装包</td><td align="center">/usr/local/src</td></tr><tr><td align="center">数据存储位置</td><td align="center">/home/fastdfs</td></tr></tbody></table><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/fastdfs      #创建数据存储目录</span><br><span class="line">cd /usr/local/src    #切换到安装目录准备下载安装包</span><br></pre></td></tr></tbody></table></figure><h1 id="安装libfatscommon"><a href="#安装libfatscommon" class="headerlink" title="安装libfatscommon"></a>安装libfatscommon</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/happyfish100/libfastcommon.git --depth 1    #下载</span><br><span class="line">cd libfastcommon/    #切换到libfastcommon文件夹下</span><br><span class="line">./make.sh && ./make.sh install   #编译安装</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/E8D0B0DB-C96A-4B5F-9591-9A9F119AA5D0.png" class="lozad"></p><h1 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd ../ #返回上一级目录</span><br><span class="line">git clone https://github.com/happyfish100/fastdfs.git --depth 1   #下载</span><br><span class="line">cd fastdfs/   #切换到fastdfs文件夹下</span><br><span class="line">./make.sh && ./make.sh install #编译安装</span><br><span class="line">#配置文件准备</span><br><span class="line">cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf   #把文件复制一份，去掉.sample</span><br><span class="line">cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf   #把文件复制一份，去掉.sample</span><br><span class="line">cp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf     ##把文件复制一份，去掉.sample,客户端文件，测试用</span><br><span class="line">cp /usr/local/src/fastdfs/conf/http.conf /etc/fdfs/       #供nginx访问使用</span><br><span class="line">cp /usr/local/src/fastdfs/conf/mime.types /etc/fdfs/     #供nginx访问使用</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/CD668118-5942-4CC3-A4BB-A69BB65F0C8D.png" class="lozad"></p><p><img alt data-src="/img/fastdfs/224E2FEF-5933-4816-ACFD-9A6522A761AB.png" class="lozad"></p><h1 id="安装fastdfs-nginx-module"><a href="#安装fastdfs-nginx-module" class="headerlink" title="安装fastdfs-nginx-module"></a>安装fastdfs-nginx-module</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../ #返回上一级目录</span><br><span class="line">git clone https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1    #下载</span><br><span class="line">cp /usr/local/src/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs   #复制到etc文件夹下的fdfs文件夹下</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/fastdfs/49E6F93C-DB97-485C-87C7-E9400D1E712E.png" class="lozad"></p><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ../ #返回上一级目录</span><br><span class="line">wget http://nginx.org/download/nginx-1.15.4.tar.gz #下载nginx压缩包</span><br><span class="line">tar -zxvf nginx-1.15.4.tar.gz #解压</span><br><span class="line">cd nginx-1.15.4/   #切换到nginx-1.15.4文件夹下</span><br><span class="line">#添加fastdfs-nginx-module模块</span><br><span class="line">./configure --add-module=/usr/local/src/fastdfs-nginx-module/src/ </span><br><span class="line">make && make install #编译安装</span><br><span class="line">/usr/local/nginx/sbin/nginx  #启动nginx</span><br></pre></td></tr></tbody></table></figure><h1 id="Tracker配置"><a href="#Tracker配置" class="headerlink" title="Tracker配置"></a>Tracker配置</h1><p>使用Xftp连接Tracker Server，打开 /etc/fdfs/tracker.conf ，需要修改以下内容</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">端口:port=22122  # tracker服务器端口（默认22122,一般不修改）</span><br><span class="line">基础目录:base_path=/home/fastdfs  # tracker运行时会向该目录存储storage的管理数据</span><br><span class="line">轮询策略:store_lookup= 0(轮询向storage存储文件)、1(指定具体的group)、2负载均衡，选择空闲的storage存储</span><br><span class="line">如果选择1策略,则需要指定一个组服务器 store_group = 组ID</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 文件服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>layer子父页面互传</title>
      <link href="/2221275439.html"/>
      <url>/2221275439.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="父页面"><a href="#父页面" class="headerlink" title="父页面"></a>父页面</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><!DOCTYPE html></span><br><span class="line"><html lang="en"></span><br><span class="line"><head></span><br><span class="line">    <meta charset="UTF-8"></span><br><span class="line">    <title>Title</title></span><br><span class="line"></head></span><br><span class="line"><body></span><br><span class="line">    <button type="button" id="test">弹出</button></span><br><span class="line">        <input id="callBackInput" placeholder="子页面回显数据" disabled/></span><br><span class="line"></body></span><br><span class="line"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script></span><br><span class="line"><script src="https://cdn.bootcss.com/layer/2.3/layer.js"></script></span><br><span class="line"><!DOCTYPE html></span><br><span class="line"><html lang="en"></span><br><span class="line"><head></span><br><span class="line">    <meta charset="UTF-8"></span><br><span class="line">    <title>Title</title></span><br><span class="line"></head></span><br><span class="line"><body></span><br><span class="line">    <button type="button" id="test">弹出</button></span><br><span class="line">        <input id="callBackInput" placeholder="子页面回显数据" disabled/></span><br><span class="line"></body></span><br><span class="line"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script></span><br><span class="line"><script src="https://cdn.bootcss.com/layer/2.3/layer.js"></script></span><br><span class="line"><script></span><br><span class="line">    $('#test').on('click',function(){</span><br><span class="line">        layer.open({</span><br><span class="line">            type: 2,</span><br><span class="line">            title: '子页面',</span><br><span class="line">            fixed: false, //不固定</span><br><span class="line">            maxmin: true,</span><br><span class="line">            shadeClose: true,</span><br><span class="line">            resize: false,</span><br><span class="line">            move: false,</span><br><span class="line">            area: ['65%', "60%"],</span><br><span class="line">            btn: ['确定','关闭'],</span><br><span class="line">            content: './zi.html',</span><br><span class="line">            success: function (layero, index) {</span><br><span class="line">                // 向子页面传递参数</span><br><span class="line">                var iframe = window['layui-layer-iframe' + index];</span><br><span class="line">                var iframeWin = window[layero.find('iframe')[0]['name']];</span><br><span class="line">                iframeWin.child(2);</span><br><span class="line">                iframe.child(1);</span><br><span class="line">            },yes:function(index,layero){</span><br><span class="line">                //获取子页面</span><br><span class="line">                var iframe = window['layui-layer-iframe' + index];</span><br><span class="line">                console.log(iframe);</span><br><span class="line">                $('#callBackInput').val(iframe.callBack());</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    });</span><br><span class="line"></script></span><br><span class="line"></html></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p>open内的属性可以忽略,这边主要看success回调这是打开页面之后的回调。layero、index都可以获取子页面DOM。</p><h1 id="子页面"><a href="#子页面" class="headerlink" title="子页面"></a>子页面</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><!DOCTYPE html></span><br><span class="line"><html lang="en"></span><br><span class="line"><head></span><br><span class="line">    <meta charset="UTF-8"></span><br><span class="line">    <title>Title</title></span><br><span class="line"></head></span><br><span class="line"><body></span><br><span class="line"><input id="testInput"  placeholder="请输入回显数据" /></span><br><span class="line"></body></span><br><span class="line"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script></span><br><span class="line"><script></span><br><span class="line">    function child(a){</span><br><span class="line">        alert(a);</span><br><span class="line">    }</span><br><span class="line">    function callBack (){</span><br><span class="line">        return $('#testInput').val();</span><br><span class="line">    }</span><br><span class="line"></script></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p>child用于接收父页面传过来的值,callBack返回父页面的回显数据。</p><h1 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h1><blockquote><p>直接走静态页面是行不通的,回报跨域异常所以这里我使用了Nginx测试。</p></blockquote><p><img alt data-src="/img/layer/E5D3A1C8-7CC2-410D-9EB0-C21BEA74A9EE.png" class="lozad"><br><img alt data-src="/img/layer/E587439F-B100-4217-9764-2E144B55C251.png" class="lozad"><br>确定和关闭按钮是父页面open中btn属性,关闭可以不用设置回调。<br><img alt data-src="/img/layer/BD23B010-8187-4004-A2CF-F3FE205141DE.png" class="lozad"></p><blockquote><p>线上环境可能要求特殊这里只做简单的测试和记录。</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> layui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> layer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博杉网站群数据导入</title>
      <link href="/4040357519.html"/>
      <url>/4040357519.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="后台设置"><a href="#后台设置" class="headerlink" title="后台设置"></a>后台设置</h1><h2 id="接口授权"><a href="#接口授权" class="headerlink" title="接口授权"></a>接口授权</h2><p>进入系统后台 -> 服务中心 -> API服务,使用AppId为8rpqaqrm的接口服务,如果需要使用API则需要勾选相应的按钮。</p><p><img alt data-src="/img/bcms/8EA023CB-3320-4409-BAFE-23247D18C13C.png" class="lozad"></p><h2 id="IP授权"><a href="#IP授权" class="headerlink" title="IP授权"></a>IP授权</h2><p>如果访问接口提示IP未授权则需要在后台配置具体: 进入系统后台 -> 系统管理 -> 系统配置。IP的话填写提示的IP即可。</p><p><img alt data-src="/img/bcms/1F29EAFC-E9B4-4BCB-8F5B-F51C3170A2AA.png" class="lozad"></p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="Excel数据"><a href="#Excel数据" class="headerlink" title="Excel数据"></a>Excel数据</h2><blockquote><p>学校方面提供数据的话由于是老系统,则用的是.net+Access开发。这类情况的话需老师提高远程桌面连接和数据文件位置,数据文件一般database里有mdb结尾的数据文件。通过Access打开可以导出Excel,一般数据存放在info导航栏数据的话在xxx_type,其次如果老网站链接有<a href="http://xxxx.xxx.xxx/News.asp" target="_blank" rel="noopener">http://xxxx.xxx.xxx/News.asp</a> 的话新闻数据在xxx_News中也需要一起导出。</p></blockquote><p><img alt data-src="/img/bcms/5520D0E4816B6E65DD4C3F32BE60AD4B.png" class="lozad"></p><p>导出的Excel如下,我们需要修改几个地方（Excel中的列头字段名称）以便程序可以读取到Excel。</p><ul><li>title = 标题</li><li>content = 内容</li><li>Sort1 = 排序一</li><li>Sort2 = 排序二</li><li>Date = 成文日期</li><li>author = 作者</li><li>AddDate = 添加日期</li></ul><p>这几个参数基本不会变如果有Sort3则可能网站数据有三级栏目则就需要加上Sort3 = 排序三,这些名称下方的JavaBean对应。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">路径: com.xinkai.bcms.excel.entity</span><br><span class="line">类名: YjsyEntity</span><br><span class="line">@Excel(name = "标题")</span><br><span class="line">private String title;</span><br><span class="line"></span><br><span class="line">@Excel(name = "内容")</span><br><span class="line">private String content;</span><br><span class="line"></span><br><span class="line">@Excel(name = "作者")</span><br><span class="line">private String author;</span><br><span class="line"></span><br><span class="line">@Excel(name = "添加时间",format = "yyyyMMddHHmmss")</span><br><span class="line">private java.util.Date releasetime;</span><br><span class="line"></span><br><span class="line">@Excel(name = "成文日期",format = "yyyyMMdd")</span><br><span class="line">private Date opendata;</span><br><span class="line"></span><br><span class="line">@Excel(name = "排序一")</span><br><span class="line">private int sorty;</span><br><span class="line"></span><br><span class="line">@Excel(name = "排序二")</span><br><span class="line">private int sortye;</span><br><span class="line"></span><br><span class="line">@Excel(name = "排序三")</span><br><span class="line">private int sortys;</span><br><span class="line"></span><br><span class="line">@Excel(name = "标题链接")</span><br><span class="line">private String linktitle;</span><br></pre></td></tr></tbody></table></figure><p>如果Excel中最后面有url列表中单元格有值,则说明该条记录的内容不是自己的,而是引用第三方网站,也就是该链接是一个链接标题 url = 标题链接。</p><h3 id="代码导入"><a href="#代码导入" class="headerlink" title="代码导入"></a>代码导入</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"> void add(){</span><br><span class="line">     List<YjsyEntity> errorList = new ArrayList<>();</span><br><span class="line">     ImportParams params = new ImportParams();</span><br><span class="line">     params.setTitleRows(0);</span><br><span class="line">     params.setHeadRows(1);</span><br><span class="line">     List<YjsyEntity> list;</span><br><span class="line">     list = ExcelImportUtil.importExcel(</span><br><span class="line">             new File("/Users/liujinyong/Downloads/统战部1Info.xlsx"),</span><br><span class="line">             YjsyEntity.class, params);</span><br><span class="line">     Set<YjsyEntity> set = list.stream().filter(e->e.getSorty()==250&&e.getSortye()==0&&e.getSortys()==0).collect(Collectors.toSet());</span><br><span class="line">     //数据大小</span><br><span class="line">     System.out.println("栏目数据:"+set.size());</span><br><span class="line">     for(YjsyEntity yjsyEntity : set){</span><br><span class="line">         AddEntity addEntity = new AddEntity();</span><br><span class="line">         BeanUtils.copyProperties(yjsyEntity,addEntity);</span><br><span class="line">         addEntity.setReleasetime(DateFormatUtil.dateToString(yjsyEntity.getReleasetime(),"yyyy-MM-dd HH:mm:ss"));</span><br><span class="line">         if(("").equals(addEntity.getLinktitle()) || addEntity.getLinktitle() == null){</span><br><span class="line">             addEntity.setLinktitle(null);</span><br><span class="line">         }</span><br><span class="line">         addEntity.setChannelid("2936");</span><br><span class="line">         addEntity.setLoginname("wyp");</span><br><span class="line">         try {</span><br><span class="line">             infoService.add(addEntity);</span><br><span class="line">         }catch (Exception e){</span><br><span class="line">             errorList.add(yjsyEntity);</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">     if(errorList.size() == 0){</span><br><span class="line">         return;</span><br><span class="line">     }</span><br><span class="line">     Workbook workbook = ExcelExportUtil.exportExcel(new ExportParams("","数据"),</span><br><span class="line">             YjsyEntity .class, errorList);</span><br><span class="line">     FileUtils.export(workbook, "错误数据.xls");</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>getSorty getSortye getSortys分别对应排序一、二、三,如果不确定排序则可以到栏目下随便复制一篇文章的标题去Excel里面查询即可知道当前栏目的排序ID。setChannelid 栏目ID可在后台通过鼠标悬浮在栏目上即可显示,只需修改排序和栏目id即可。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 博杉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据导入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS Tracker Storage</title>
      <link href="/3849896659.html"/>
      <url>/3849896659.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="为何使用FastDFS"><a href="#为何使用FastDFS" class="headerlink" title="为何使用FastDFS"></a>为何使用FastDFS</h1><p>业界也有很多出门的分布式文件系统如:GFS、HDFS,其次这些都是通用（大小文件都可以使用）型的分布式文件系统,优点开发体验好但是系统复杂性高、性能一般。而专用的分布式文件系统虽然开发体验极差,但是系统复杂度低并且性能高。<br>FastDFS非常适合存储小文件,FastDFS不对文件进行分块所以少了分块合并的开销,FastDFS采用Socket通信速度很快。</p><h1 id="FastDFS介绍"><a href="#FastDFS介绍" class="headerlink" title="FastDFS介绍"></a>FastDFS介绍</h1><blockquote><p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。<br>FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。  </p></blockquote><h2 id="Tracker"><a href="#Tracker" class="headerlink" title="Tracker"></a>Tracker</h2><p>Tracker Server 作用是负载均衡和服务调度中心,客户端通过访问Tracker文件上传时,可以根据一些策略（轮询、单机、负载均衡）找到Storage提供的文件上传服务。可以将tracker称为追踪服务器或调度服务器。  </p><p>Tracker Server 可以有多台之前相互平等的提供服务,不存在单点故障。客户端通过轮询策略进行访问,若A无法提供服务就切换B执行。</p><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>Storage Server 作用是存储文件,客户端上传的文件最终存储在Storage服务器中,Storage使用操作系统的文件系统来管理文件。可以将Storage称为存储服务器。  </p><p>Storage Server 采用集群分组。Storage集群有一个或多个组构成,集群的存储容量为所有组的容量之和。<br>一组由一台或多台Storage组成,组内的Storage是平等关系,不同组的Storage不会进行通信,而同一组的Storage会进行文件同步（备份）,从而保证一组中多个Storage的文件一致。  </p><p>Storage分组（冗余备份、负载均衡）保证了系统的灵活、可控性。客户端上传文件可以单独指定组上传也可以通过Tracker进行调度选择。当一组存储服务器压力过大可以选择在该组增加Storage来扩充服务能力（纵向扩容）,在增加服务器时,会同步已有的文件由系统自动同步,文件同步之后系统自动将新增的服务器切换上线使用。<br>当系统容量存储不足时可加组来增加服务器容量（横向扩容）。</p><p><img alt data-src="/img/fastdfs/C87BAF1A-C090-4FF5-ADAB-5C471CD78EEA.png" class="lozad">  </p><p>多个Client（客户端）进行对多个Tracker（跟踪器）访问,这里Tracker作用为调度中心和负载均衡。<br>Storage会主动向Tracker发送自身状态和存储信息,Tracker通过相应的策略调度Storage来进行文件存储,客户端也可以直接通过Storage存储。</p><h1 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h1><p><img alt data-src="/img/fastdfs/1C590352-695B-4E27-8AB6-7955079D547D.png" class="lozad"></p><p>Storage先向Tracker提供自身状态、存储信息,客户端通过连接Tracker进行调度,将可用的Storage返回（IP:Port）之后进行文件上传,生成FileID（文件路径）且把上传信息写入磁盘,并将FileID返回客户端,存储文件信息。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#FileId - group1/M00/03/33/wKMsDtDtgKRjAWWWWWW1235213.sh</span><br></pre></td></tr></tbody></table></figure><p>group1:这是分组名称,如果多个分组则:group1、group2以此类推需自行设置。</p><p>M00:虚拟磁盘路径,与配置文件中的storage_path对应如果storage_path0 则对应 M00 、storage_path1 则对应 M01 以此类推。</p><p>03/33:storage会自动在配置路径中创建二级目录,用于存储文件。</p><p>文件名:与上传时不同,由系统自动生成。</p><h1 id="文件下载流程"><a href="#文件下载流程" class="headerlink" title="文件下载流程"></a>文件下载流程</h1><p><img alt data-src="/img/fastdfs/D94F82E1-82CD-48B4-A01D-548FE4EB49F7.png" class="lozad"></p><p>下载流程与上传文件大致相识,客户端连接Tracker之后调度可用的Storage返回,通过FileId进行文件下载返回文件内容。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 文件服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务失效之谜</title>
      <link href="/1197182840.html"/>
      <url>/1197182840.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>本文章通过SpringBoot2.2.0.RELEASE,mybatis-spring-boot-starter2.1.1构建的测试项目。</p></blockquote><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Nav {</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Integer pid;</span><br><span class="line"></span><br><span class="line">    private String des;</span><br><span class="line"></span><br><span class="line">    private String key;</span><br><span class="line"></span><br><span class="line">    public Nav(String name, Integer pid) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.pid = pid;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface NavMapper {</span><br><span class="line">    /**</span><br><span class="line">     * 保存</span><br><span class="line">     * @param nav</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    void save(Nav nav);</span><br><span class="line">    /**</span><br><span class="line">     * 根据Id获取导航栏</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Nav getById(Integer id);</span><br><span class="line">    /**</span><br><span class="line">     * 更新对象</span><br><span class="line">     * @param nav</span><br><span class="line">     */</span><br><span class="line">    void update(Nav nav);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Mapper-Xml"><a href="#Mapper-Xml" class="headerlink" title="Mapper Xml"></a>Mapper Xml</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><?xml version="1.0" encoding="UTF-8"?></span><br><span class="line"><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><br><span class="line"></span><br><span class="line"><mapper namespace="com.animo.mybatis.mapper.NavMapper"></span><br><span class="line"></span><br><span class="line">    <insert id="save" parameterType="com.animo.mybatis.entity.Nav"</span><br><span class="line">            useGeneratedKeys="true" keyProperty="id"></span><br><span class="line">        insert into nav (name,pid) values (#{name},#{pid})</span><br><span class="line">    </insert></span><br><span class="line"></span><br><span class="line">    <update id="update"></span><br><span class="line">      update nav set name = #{name} where id = #{id}</span><br><span class="line">    </update></span><br><span class="line"></span><br><span class="line">    <select id="getById" resultType="com.animo.mybatis.entity.Nav"></span><br><span class="line">        select id,name from nav where id = #{-parameters}</span><br><span class="line">    </select></span><br><span class="line"></mapper></span><br></pre></td></tr></tbody></table></figure><p>#{-parameters}:当你在处理一个带有多个形参的构造方法时，很容易搞乱 arg 元素的顺序。 从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。 为了通过名称来引用构造方法参数，你可以添加 @Param 注解，或者使用 ‘-parameters’ 编译选项并启用 useActualParamName 选项（默认开启）来编译项目。</p><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void transactionalTest(Integer id){</span><br><span class="line">        try {</span><br><span class="line">            //1.先查询</span><br><span class="line">            Nav nav = navMapper.getById(id);</span><br><span class="line">            //2.更新</span><br><span class="line">            nav.setName("事务测试更新");</span><br><span class="line">            navMapper.update(nav);</span><br><span class="line">            //3.新增</span><br><span class="line">            navMapper.save(new Nav("事务测试保存",3));</span><br><span class="line">            FileOutputStream fileOutputStream = new FileOutputStream(new File("/usr/local/xxx.html"));</span><br><span class="line">            //.....重要代码</span><br><span class="line">        }catch (IOException e){</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这边多条SQL操作需开启事务保证原子性,代码中有个文件找不到异常这里是测试异常,不过业务角度的话可能是很重要的代码需要被捕获。</p><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><blockquote><p>事务的话遇到异常就会回滚所以我们带着这个理念测试类执行以下代码之后的数据库前后的状态。</p></blockquote><ul><li>执行前数据状态</li></ul><p><img alt data-src="/img/SpringBoot/52906B39-5CEE-40A3-BE14-369D15BAF23E.png" class="lozad"></p><p>这边代码执行之后肯定是报异常了java.io.FileNotFoundException: /usr/local/xxx.html (Permission denied),很显然事务回滚失效了。  </p><ul><li>执行后数据状态</li></ul><p><img alt data-src="/img/SpringBoot/04BA2820-1CD0-4A2C-BC90-FE74C7E50569.png" class="lozad"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p>程序运行如果没有错误会自动提交事务,如果程序发生异常则会自动回滚。<br>但是如果使用了try捕获异常（检查时异常）时,一定要注意在catch里面手动回滚否者事务失效。</p></blockquote><h2 id="手动回滚"><a href="#手动回滚" class="headerlink" title="手动回滚"></a>手动回滚</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try{</span><br><span class="line">    //重要代码</span><br><span class="line">}catch(Exception e){</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try{</span><br><span class="line">    //重要代码</span><br><span class="line">}catch(Exception e){</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    throw new Exception();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不过这边推荐手动回滚,如果有调用者的话抛异常需要一层一层往上直到controller层。<br>以上两种方式可自行测试下效果我这边使用手动回滚事务不会失效。</p><blockquote><p>以上文章内容是目前本人现在的见解,如果有更深层次的话会继续更新/修改。</p></blockquote></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web常用工具类</title>
      <link href="/381971134.html"/>
      <url>/381971134.html</url>
      
        <content type="html"><![CDATA[<h1 id="RestTemplate请求工具类"><a href="#RestTemplate请求工具类" class="headerlink" title="RestTemplate请求工具类"></a>RestTemplate请求工具类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.http.HttpEntity;</span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.http.HttpMethod;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.http.client.SimpleClientHttpRequestFactory;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line">public class RestTemplateUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final RestTemplate restTemplate &#x3D; new RestTemplate();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">        &#x2F;&#x2F; 设置连接超时</span><br><span class="line">         requestFactory.setConnectTimeout(5000);</span><br><span class="line">        restTemplate.setRequestFactory(requestFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ----------------------------------GET-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, Class&lt;T&gt; responseType) &#123;</span><br><span class="line">        return restTemplate.getForEntity(url, responseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        return restTemplate.getForEntity(url, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        return restTemplate.getForEntity(url, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, Map&lt;String, String&gt; headers, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        HttpHeaders httpHeaders &#x3D; new HttpHeaders();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        return get(url, httpHeaders, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, HttpHeaders headers, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        HttpEntity&lt;?&gt; requestEntity &#x3D; new HttpEntity&lt;&gt;(headers);</span><br><span class="line">        return exchange(url, HttpMethod.GET, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, Map&lt;String, String&gt; headers, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        HttpHeaders httpHeaders &#x3D; new HttpHeaders();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        return get(url, httpHeaders, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的GET请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; get(String url, HttpHeaders headers, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        HttpEntity&lt;?&gt; requestEntity &#x3D; new HttpEntity&lt;&gt;(headers);</span><br><span class="line">        return exchange(url, HttpMethod.GET, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ----------------------------------POST-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, Object requestBody, Class&lt;T&gt; responseType) &#123;</span><br><span class="line">        return restTemplate.postForEntity(url, requestBody, responseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        return restTemplate.postForEntity(url, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        return restTemplate.postForEntity(url, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        HttpHeaders httpHeaders &#x3D; new HttpHeaders();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        return post(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity &#x3D; new HttpEntity&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        return post(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        HttpHeaders httpHeaders &#x3D; new HttpHeaders();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        return post(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 带请求头的POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url          请求URL</span><br><span class="line">     * @param headers      请求头参数</span><br><span class="line">     * @param requestBody  请求参数体</span><br><span class="line">     * @param responseType 返回对象类型</span><br><span class="line">     * @param uriVariables URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity &#x3D; new HttpEntity&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        return post(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义请求头和请求体的POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url           请求URL</span><br><span class="line">     * @param requestEntity 请求头和请求体封装对象</span><br><span class="line">     * @param responseType  返回对象类型</span><br><span class="line">     * @param uriVariables  URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        return restTemplate.exchange(url, HttpMethod.POST, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义请求头和请求体的POST请求调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url           请求URL</span><br><span class="line">     * @param requestEntity 请求头和请求体封装对象</span><br><span class="line">     * @param responseType  返回对象类型</span><br><span class="line">     * @param uriVariables  URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; post(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        return restTemplate.exchange(url, HttpMethod.POST, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ----------------------------------通用方法-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通用调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url           请求URL</span><br><span class="line">     * @param method        请求方法类型</span><br><span class="line">     * @param requestEntity 请求头和请求体封装对象</span><br><span class="line">     * @param responseType  返回对象类型</span><br><span class="line">     * @param uriVariables  URL中的变量，按顺序依次对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables) &#123;</span><br><span class="line">        return restTemplate.exchange(url, method, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通用调用方式</span><br><span class="line">     *</span><br><span class="line">     * @param url           请求URL</span><br><span class="line">     * @param method        请求方法类型</span><br><span class="line">     * @param requestEntity 请求头和请求体封装对象</span><br><span class="line">     * @param responseType  返回对象类型</span><br><span class="line">     * @param uriVariables  URL中的变量，与Map中的key对应</span><br><span class="line">     * @return ResponseEntity 响应对象封装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) &#123;</span><br><span class="line">        return restTemplate.exchange(url, method, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取RestTemplate实例对象，可自由调用其方法</span><br><span class="line">     *</span><br><span class="line">     * @return RestTemplate实例对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static RestTemplate getRestTemplate() &#123;</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringContextUtil获取Bean"><a href="#SpringContextUtil获取Bean" class="headerlink" title="SpringContextUtil获取Bean"></a>SpringContextUtil获取Bean</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class SpringContextUtil implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        SpringContextUtil.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name) &#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac/Linux下工具安装(持续更新中~)</title>
      <link href="/3205076647.html"/>
      <url>/3205076647.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-Maven"><a href="#Mac-Maven" class="headerlink" title="Mac Maven"></a>Mac Maven</h1><ol><li>下载地址 <a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a>  </li><li>双击解压之后放到安装路径  </li><li>设置环境变量vim ~/.bash_profile</li></ol><ul><li>export M2_HOME=”/usr/local/apache-maven-3.6.0”  </li><li>export PATH=”$M2_HOME/bin:$PATH”</li></ul><ol start="4"><li>刷新配置文件source ~/.bash_profile</li><li>检查是否安装成功 mvn -v</li></ol><h1 id="Mac-Jmeter"><a href="#Mac-Jmeter" class="headerlink" title="Mac Jmeter"></a>Mac Jmeter</h1><ol><li>下载地址<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></li><li>双击解压之后放到安装路径</li><li>执行jmeter</li></ol><ul><li>cd /usr/local/apache-jmeter-5.1.1/bin</li><li>sh jmeter</li></ul><ol start="4"><li>设置中文</li></ol><ul><li>Options-&gt;Choose Language-&gt;Chinese（Simplified）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式入门</title>
      <link href="/3778527093.html"/>
      <url>/3778527093.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。</p></blockquote><h1 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h1><p>顾名思义何为函数接口和普通接口又有什么区别？<br>自JDK8以来接口可以有多个默认实现方法（普通接口）。<br><img alt data-src="/img/wechat/44B38720-73AE-4893-8A43-CBA613F6DFDA.png" class="lozad"><br>普通接口上增加@FunctionalInterface即标识为函数接口,与其普通接口的区别在于函数接口只能有一个抽象方法,多个会报错。<br><img alt data-src="/img/wechat/63F019B6-FD74-4ECE-B177-794612718D08.png" class="lozad"><br>JDK8为我们提供了很多函数接口在java.util.function包下。<br><img alt data-src="/img/wechat/D427643F-C8A5-4446-BAAE-2687D5A1AE47.png" class="lozad"><br>函数接口给lambda带来了什么？<br>根据开头介绍Lambda是一个匿名函数,何为匿名函数？我们常见的匿名函数出现在Swing比较多,线程大家也知道举个例子。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) {</span><br><span class="line">        Thread thread = new Thread(()-> System.out.println("123123"));</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这段代码很简单我们创建了个Thread,这里我们使用了需要Runnable接口的构造函数,为什么我们能使用Lambda表达式呢？因为Runnable接口遵循了函数接口设计规则。<br><img alt data-src="/img/wechat/51A5B607-3EB5-4B89-BD9C-601C26AC8BE0.png" class="lozad"><br><img alt data-src="/img/wecgat/FF6594EB-FE78-4858-B262-5461461FF7A0.png" class="lozad"><br>这里我们可以看到Runnable函数接口只有一个方法然而方法没有形参所以我们可以通过()->逻辑代码这种形式去抒写。</p><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>这里我们通过对集合的练习Lambda让大家有更深入的了解。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Transaction {</span><br><span class="line">    private final Trader trader;</span><br><span class="line">    private final int year;</span><br><span class="line">    private final int value;</span><br><span class="line">    public Transaction(Trader trader, int year, int value) {</span><br><span class="line">        this.trader = trader;</span><br><span class="line">        this.year = year;</span><br><span class="line">        this.value = value;</span><br><span class="line">    }</span><br><span class="line">    public Trader getTrader() {</span><br><span class="line">        return trader;</span><br><span class="line">    }</span><br><span class="line">    public int getYear() {</span><br><span class="line">        return year;</span><br><span class="line">    }</span><br><span class="line">    public int getValue() {</span><br><span class="line">        return value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class Trader{</span><br><span class="line">    private final String name;</span><br><span class="line">    private final String city;</span><br><span class="line">    public String getName() {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">    public String getCity() {</span><br><span class="line">        return city;</span><br><span class="line">    }</span><br><span class="line">    public Trader(String name, String city) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.city = city;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建集合数据。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Trader raoul = new Trader("Raoul", "Cambridge");</span><br><span class="line">        Trader mario = new Trader("Mario","Milan");</span><br><span class="line">        Trader alan = new Trader("Alan","Cambridge");</span><br><span class="line">        Trader brian = new Trader("Brian","Cambridge");</span><br><span class="line">        List<Transaction> transactions = Arrays.asList(</span><br><span class="line">                new Transaction(brian, 2011, 300),</span><br><span class="line">                new Transaction(raoul, 2012, 1000),</span><br><span class="line">                new Transaction(raoul, 2011, 400),</span><br><span class="line">                new Transaction(mario, 2012, 710),</span><br><span class="line">                new Transaction(mario, 2012, 700),</span><br><span class="line">                new Transaction(alan, 2012, 950)</span><br><span class="line">        );</span><br></pre></td></tr></tbody></table></figure><p>1、找出2011年发生的所有交易，并按交易额排序(从低到高)。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List<Transaction> list1 = transactions.stream().</span><br><span class="line">filter(e->e.getYear()==2011).</span><br><span class="line">sorted(Comparator.comparing(Transaction::getValue)).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></tbody></table></figure><p>首先通过transactions获取Stream API流,这里需要找出2011年所发生的的所有交易所以我们这里使用filter过滤结果集,下方是filter方法源码,可以看到需要的入参是一个函数接口,这里就可以采用Lambda。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<T> filter(Predicate<? super T> predicate);</span><br></pre></td></tr></tbody></table></figure><p>Predicate函数接口默认方法test 入参是一个泛型T所以我们可以传递Transaction对象,我们可以采用两种形式写Lambda可以隐式也可以显式,为了方便采用第一种。<br>在filter之后的list已经被过滤了只有2011年的数据,又需要排序这里采用sorted,方法入参又是一个函数接口。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<T> sorted(Comparator<? super T> comparator);源码</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(Comparator.comparing(Transaction::getValue))代码</span><br></pre></td></tr></tbody></table></figure><p>入参我们采用了静态方法默认实现了里面的排序,静态方法入参是一个Function函数接口。<br><img alt data-src="/img/wechat/3B3BA85D-2CEB-40E2-A015-12E88C32E8B8.png" class="lozad"><br>入参我们采用了语法糖Transaction::getValue = e->e.getValue(),综上所诉此阶段我们已经把2011排序之后的数据组装完成,这时候需要用到collect把组装的数据转换成集合再次输出到结果集这里就完成了筛选和排序,其实lambda和流水线差不多把需要做的事情一步一步做完之后再输出成成品。</p><p>2、交易员都在哪些不同的城市工作过</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set<String> list2 = transactions.stream().</span><br><span class="line">map(e->e.getTrader().getCity()).</span><br><span class="line">collect(Collectors.toSet());</span><br></pre></td></tr></tbody></table></figure><p>map主要作用用来拉去对象中的特定属性,因为问题中的不同,所以我们采用toSet方法来去重,也可以采用distinct()在toList。  </p><p>3、查找所有来自于剑桥的交易员，并按姓名排序</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set<Trader> list3 = transactions.stream().</span><br><span class="line">map(e->e.getTrader()).</span><br><span class="line">filter(e->e.getCity().equals("Cambridge")).</span><br><span class="line">sorted(Comparator.comparing(Trader::getName)).</span><br><span class="line">collect(Collectors.toSet());</span><br></pre></td></tr></tbody></table></figure><p>因为Trader在Transaction所以我们需要用map把Trader抽取出来之后再进行城市过滤,过滤之后把名字排序在去重相同名字。  </p><p>4、返回所有交易员的姓名字符串，按字母顺序排序</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String list4 = transactions.stream().</span><br><span class="line">map(e->e.getTrader().getName()).</span><br><span class="line">distinct().</span><br><span class="line">sorted().</span><br><span class="line">reduce("",(a,b)->a+b);</span><br></pre></td></tr></tbody></table></figure><p>通过map把所有交易员的姓名抽取出来之后去重在通过排序默认从小到大，reduce方法就是把两个值结合起来生成新的值。<br>此方法效率不高因为每次迭代都会产生新的String,下方为优化代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tring traderStr = transactions.stream()</span><br><span class="line">.map(transaction -> transaction.getTrader().getName())</span><br><span class="line">.distinct()</span><br><span class="line">.sorted()</span><br><span class="line">.collect(joining());</span><br></pre></td></tr></tbody></table></figure><p>5、有没有交易员是在米兰工作的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean list5 = transactions.stream().</span><br><span class="line">anyMatch(e->e.getTrader().getCity().equals("Milan"))</span><br></pre></td></tr></tbody></table></figure><p>anyMatch入参是一个Predicate函数接口和第一题中的filter入参一样,那为什么不用filter,这里出现个问题为什么不使用filter其效果也是一样的呀?<br>filter属于中间操作可以链接起来,将一个流转换成另一个流。这个操作不会去消耗流其目的是创建新的流所以还在”流水线”并未将其结果返回。与其相反,终端操作会消耗流,以产生一个最终结果,它们通常可以优化”流水线”来缩短计算时间。  </p><p>6、打印生活在剑桥的交易员的所有交易额</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transactions.stream().</span><br><span class="line">filter(e->"Cambridge".equals(e.getTrader().getCity())).</span><br><span class="line">map(Transaction::getValue).</span><br><span class="line">forEach(System.out::println);</span><br></pre></td></tr></tbody></table></figure><p>过滤出在剑桥的交易员,通过map提取出交易额在循环打印。  </p><p>7、所有交易中，最高的交易额是多少</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional<Integer> integer =  transactions.stream().</span><br><span class="line">map(Transaction::getValue).</span><br><span class="line">reduce(Integer::max);</span><br></pre></td></tr></tbody></table></figure><p>这里返回值是用Optional包裹的,JKD8加入的Optional预防空指针。  </p><p>8、找到交易额最小的交易</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional<Transaction> transaction = transactions.stream().</span><br><span class="line">reduce((a,b)->a.getValue()<b.getValue()?a:b);</span><br></pre></td></tr></tbody></table></figure><p>9、附加:交易额求和</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int value = transactions.stream().</span><br><span class="line">mapToInt(Transaction::getValue).sum();</span><br></pre></td></tr></tbody></table></figure><p>以上就是一些基础的Lambda表达式,重要的不是去使用而是去理解该如何写,了解了函数接口之后再通过一系列的语法糖和静态方法,也能随心所欲的写出Lambda,更多关于函数接口和Lambda的高级使用可以购买JDK8实战书籍。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> JDK1.8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac Docker Nginx本地化</title>
      <link href="/3300602767.html"/>
      <url>/3300602767.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="宿主机文件"><a href="#宿主机文件" class="headerlink" title="宿主机文件"></a>宿主机文件</h1><p>创建一个临时的Nginx容器来拷贝出配置文件。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name tempNginx nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp tempNginx:/etc/nginx /usr/local/nginx</span><br></pre></td></tr></tbody></table></figure><p>这里我选择了放在/usrl/local目录下,这里会有个权限问题你们可以放在其他目录比如文档、或者用户目录。这边我们进入目录查看一下是否拷贝成功。</p><p><img alt data-src="/img/wechat/C229C620-CA12-4A22-B152-05CB9173E8B5.png" class="lozad"></p><p>这里检查文件存在之后即可删除临时的Nginx容器。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f tempNginx</span><br></pre></td></tr></tbody></table></figure><h1 id="创建Nginx容器"><a href="#创建Nginx容器" class="headerlink" title="创建Nginx容器"></a>创建Nginx容器</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged=true --name nginx -d -p 80:80 </span><br><span class="line">-v /usr/local/nginx:/etc/nginx </span><br><span class="line">-v /Users/xxx/Documents/xxx/xxx:/usr/local/xxx/xxx </span><br><span class="line">nginx</span><br></pre></td></tr></tbody></table></figure><p>第一个-v做了nginx配置的映射<br>第二个-v做了前端项目的映射<br>这里可能会提示权限问题和拒绝挂载,权限问题的话可以调整文件夹权限，拒绝挂载这边的话需要在Docker图形界面配置。<br><img alt data-src="/img/wechat/996A4AE9-BD83-4494-8B19-A8445B8CE0B0.png" class="lozad"></p><p>此时我们直接编辑本地的nginx.conf在最后一行添加注释,其次我们在进入容器中查看。<br><img alt data-src="/img/wechat/84A071C3-DEA9-4B53-A94E-C5F8AEFD7048.png" class="lozad"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入容器:docker exec -it nginx bash 进入目录:/etc/nginx</span><br></pre></td></tr></tbody></table></figure><p>由于Docker不带有vim命令所以使用cat命令,所以映射这边我们生效了。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nginx.conf</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="/img/wechat/5053387E-6A10-4B95-AFA2-BD3E56F2557C.png" class="lozad"></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>由于nginx.conf主配置文件中包含了/ect/nginx/conf.d/*.conf所以我在这里进行代理。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name www.xxx.com; #host映射的域名</span><br><span class="line">    #前端页面</span><br><span class="line">    location / {</span><br><span class="line">        alias  路径; #刚才映射路径这里填写容器里面的路径</span><br><span class="line">        index  index.html; #默认访问值</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面配置之前我们先把原有的配置先注释掉,修改之后再通过以下命令进行重启。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已经进入容器: nginx -s reload</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未进入容器: docker exec -i nginx nginx -s reload</span><br></pre></td></tr></tbody></table></figure><p>以上命令执行出现以下结果则通过。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/10/14 11:29:46 [notice] 102#102: signal process started</span><br></pre></td></tr></tbody></table></figure><p>这样的话我们就可以通过server_name或者ip地址去访问。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web接入QQ第三方登录</title>
      <link href="/3480530518.html"/>
      <url>/3480530518.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>第三方网站主要通过使用“QQ登录”接入QQ互联开放平台。“QQ登录”是QQ互联开放平台提供给第三方网站的一种服务。“QQ登录”可以让用户使用QQ帐号在第三方网站上登录，分享内容、同步信息，大大降低了用户注册的门槛。同时，第三方网站根据用户提供的绑定信息，将用户在网站上发布的内容同步发布到QQ空间的个人动态中，从而借助QQ空间庞大的用户群，使网站的信息能通过好友关系得到进一步的传播，提升网站的访问量和用户数。</p></blockquote><p><img alt data-src="/img/wechat/67B830CD-98AB-4092-A107-9D04DDEA977F.png" class="lozad"></p><h1 id="账号申请"><a href="#账号申请" class="headerlink" title="账号申请"></a>账号申请</h1><p>进入QQ互联 <a href="https://connect.qq.com。" target="_blank" rel="noopener">https://connect.qq.com。</a><br>右上角点击登录,登录之后点击头像会进入到申请页面。这里我们选择个人接入,需要准备一下手持身份证照片。</p><p><img alt data-src="/img/wechat/91189468-4DF3-488E-AA77-9455C2C2C9D6.png" class="lozad"></p><p>完成注册提交审核之后会有几个小时的等待时间,一般情况都是可以下来的,主要是手持身份证</p><p><img alt data-src="/img/wechat/30F516B7-6D6A-4A1C-A7AA-919E3F49D654.png" class="lozad"></p><p>点击应用管理->选择网站应用->创建应用,里面资料都可以随意填写。</p><p><img alt data-src="/img/wechat/A48C57E5-952F-401D-96C8-0C0485C82DD3.png" class="lozad"></p><p>点击创建应用之后会跳到填写网站域名的地方,这里我们还是采用Natapp内网穿透</p><p><img alt data-src="/img/wechat/A20FDDBB-DCCB-4879-8695-B98A7049196A.png" class="lozad"></p><p>创建之后可以再应用管理查看，点击查看会看到相应的应用信息，主要关注appid和回调地址会用到。</p><p><img alt data-src="/img/wechat/2D8B4A5C-9982-48D9-80F1-CF2EB172D67A.png" class="lozad"></p><p><img alt data-src="/img/wechat/762A855B-5BA8-49E4-942A-C293C4E22D53.png" class="lozad"></p><p>下方的平台信息是可以随时修改的,方便我们测试,免费的Natapp会随时更换域名大家如果测试阶段发现错误可能就是映射域名已更换不符合配置域名。</p><p><img alt data-src="/img/wechat/81FBDEF5-E0F5-4284-BACC-D9E03FEA9159.png" class="lozad"></p><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><p>创建SpringBoot的Web项目,具体pom如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><?xml version="1.0" encoding="UTF-8"?></span><br><span class="line"><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></span><br><span class="line">    <modelVersion>4.0.0</modelVersion></span><br><span class="line">    <parent></span><br><span class="line">        <groupId>org.springframework.boot</groupId></span><br><span class="line">        <artifactId>spring-boot-starter-parent</artifactId></span><br><span class="line">        <version>2.1.6.RELEASE</version></span><br><span class="line">        <relativePath/> <!-- lookup parent from repository --></span><br><span class="line">    </parent></span><br><span class="line">    <groupId>com.animo.boot</groupId></span><br><span class="line">    <artifactId>springboot-qq</artifactId></span><br><span class="line">    <version>0.0.1-SNAPSHOT</version></span><br><span class="line">    <name>springboot-qq</name></span><br><span class="line">    <description>Demo project for Spring Boot</description></span><br><span class="line">    <properties></span><br><span class="line">        <java.version>1.8</java.version></span><br><span class="line">    </properties></span><br><span class="line">    <dependencies></span><br><span class="line">        <dependency></span><br><span class="line">            <groupId>org.springframework.boot</groupId></span><br><span class="line">            <artifactId>spring-boot-starter-web</artifactId></span><br><span class="line">        </dependency></span><br><span class="line">        <dependency></span><br><span class="line">            <groupId>org.apache.httpcomponents</groupId></span><br><span class="line">            <artifactId>httpclient</artifactId></span><br><span class="line">        </dependency></span><br><span class="line">        <dependency></span><br><span class="line">            <groupId>com.google.code.gson</groupId></span><br><span class="line">            <artifactId>gson</artifactId></span><br><span class="line">        </dependency></span><br><span class="line">    </dependencies></span><br><span class="line">    <build></span><br><span class="line">        <plugins></span><br><span class="line">            <plugin></span><br><span class="line">                <groupId>org.springframework.boot</groupId></span><br><span class="line">                <artifactId>spring-boot-maven-plugin</artifactId></span><br><span class="line">            </plugin></span><br><span class="line">        </plugins></span><br><span class="line">    </build></span><br><span class="line"></project></span><br></pre></td></tr></tbody></table></figure><p>YML和外部化配置类。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">connect:</span><br><span class="line">  appId: 101744617</span><br><span class="line">  appKey: 8f7784b6b582b1d2117f34b549ad3193</span><br><span class="line">  uri: http://v3gapy.natappfree.cc</span><br><span class="line">  returnUri: ${connect.uri}/callback</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = "connect")</span><br><span class="line">public class ConnectConfig {</span><br><span class="line">    /**</span><br><span class="line">     * appID</span><br><span class="line">     */</span><br><span class="line">    private String appId;</span><br><span class="line">    /**</span><br><span class="line">     * appKey</span><br><span class="line">     */</span><br><span class="line">    private String appKey;</span><br><span class="line">    /**</span><br><span class="line">     * 回调的url</span><br><span class="line">     */</span><br><span class="line">    private String returnUri;</span><br><span class="line">    /**</span><br><span class="line">     * 项目的域名 为了方便测试</span><br><span class="line">     */</span><br><span class="line">    private String uri;</span><br><span class="line">    //省略Get Set</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>工具类封装授权URL。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 刘金泳</span><br><span class="line"> * @Date 2019/8/5</span><br><span class="line"> */</span><br><span class="line">public class ConnectUtil {</span><br><span class="line">    /**</span><br><span class="line">     * 授权地址</span><br><span class="line">     * @param appId</span><br><span class="line">     * @param redirectUri</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getAuthorize(String appId,String redirectUri){</span><br><span class="line">        /**</span><br><span class="line">         * 这里需要随机生成在和客户端传过来的state进行对比,防止CSRF攻击。</span><br><span class="line">         */</span><br><span class="line">        String state = "12n2x94h124vgh1249";</span><br><span class="line">        String url = "https://graph.qq.com/oauth2.0/authorize?response_type=code&client_id=%s&redirect_uri=%s&state=%s";</span><br><span class="line">        try {</span><br><span class="line">            return String.format(url,appId,URLEncoder.encode(redirectUri,"UTF-8"),state);</span><br><span class="line">        } catch (UnsupportedEncodingException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 获取AccessToken</span><br><span class="line">     * @param appId</span><br><span class="line">     * @param appKey</span><br><span class="line">     * @param code</span><br><span class="line">     * @param redirectUri</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getAccessToken(String appId,String appKey,String code,String redirectUri){</span><br><span class="line">        String url = "https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&client_id=%s&client_secret=%s&code=%s&redirect_uri=%s";</span><br><span class="line">        try {</span><br><span class="line">            return String.format(url,appId,appKey,code,URLEncoder.encode(redirectUri,"UTF-8"));</span><br><span class="line">        } catch (UnsupportedEncodingException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 获取openId</span><br><span class="line">     * @param accessToken</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getOpenId(String accessToken){</span><br><span class="line">        return "https://graph.qq.com/oauth2.0/me?access_token="+accessToken;</span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 获取用户信息</span><br><span class="line">     * @param accessToken</span><br><span class="line">     * @param appId</span><br><span class="line">     * @param openId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getUserInfo(String accessToken , String appId, String openId){</span><br><span class="line">        String url = "https://graph.qq.com/user/get_user_info?access_token=%s&oauth_consumer_key=%s&openid=%s";</span><br><span class="line">        return String.format(url,accessToken,appId,openId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制器层代码只是简单的作为测试例子,更多逻辑操作还得自行添加。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class CallbackController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConnectConfig connectConfig;</span><br><span class="line">    @RequestMapping("/login")</span><br><span class="line">    public String qqLogin(){</span><br><span class="line">        return "redirect:"+ ConnectUtil.getAuthorize(connectConfig.getAppId(),connectConfig.getReturnUri());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("/callback")</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String callBack(HttpServletRequest request){</span><br><span class="line">        String code = request.getParameter("code");</span><br><span class="line">        String state = request.getParameter("state");</span><br><span class="line">        String accessTokenUrl = ConnectUtil.getAccessToken(connectConfig.getAppId(),connectConfig.getAppKey(),code,connectConfig.getReturnUri());</span><br><span class="line">        /**</span><br><span class="line">         * 此方法业务逻辑自行设计 需要结合缓存</span><br><span class="line">         */</span><br><span class="line">        try {</span><br><span class="line">            //获取AccessToken</span><br><span class="line">            HttpClientDto accessTokenDto = HttpClientUtil.doGet(accessTokenUrl);</span><br><span class="line">            String [] strings = accessTokenDto.getContent().split("&");</span><br><span class="line">            Map<String,String> map = new HashMap<>(16);</span><br><span class="line">            map.put("access_token",strings[0].split("=")[1]);</span><br><span class="line">            map.put("expires_in",strings[1].split("=")[1]);</span><br><span class="line">            map.put("refresh_token",strings[2].split("=")[1]);</span><br><span class="line">            //获取OpenId</span><br><span class="line">            HttpClientDto openDto = HttpClientUtil.doGet(ConnectUtil.getOpenId(map.get("access_token")));</span><br><span class="line">            String[] strings1 =  openDto.getContent().split(" ");</span><br><span class="line">            Map<String,Object> openMap = GsonUtil.JsonToMap(strings1[1]);</span><br><span class="line">            //获取用户信息</span><br><span class="line">            HttpClientDto userInfo =  HttpClientUtil.doGet(ConnectUtil.getUserInfo(map.get("access_token"),connectConfig.getAppId(),openMap.get("openid").toString()));</span><br><span class="line">            /**</span><br><span class="line">             * 这里应该是ModeAndView  把头像和昵称放进map和页面一起返回</span><br><span class="line">             */</span><br><span class="line">            return userInfo.getContent();</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        return "回调";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前端页面代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><!DOCTYPE html></span><br><span class="line"><html lang="en"></span><br><span class="line"><head></span><br><span class="line">    <meta charset="UTF-8"></span><br><span class="line">    <title>QQ登录</title></span><br><span class="line"></head></span><br><span class="line"><body></span><br><span class="line">    <img src="/image/Connect_logo_5.png" onclick="toLogin()"></span><br><span class="line"></body></span><br><span class="line"><script src="http://code.jquery.com/jquery-2.1.1.min.js"></script></span><br><span class="line"><script type="text/javascript"></span><br><span class="line">    //在新标签页打开网站</span><br><span class="line">    function toLogin() {</span><br><span class="line">        window.open("/login", "TencentLogin",</span><br><span class="line">            "width=450,height=320,menubar=0,scrollbars=1,resizable=1,status=1,titlebar=0,toolbar=0,location=1");</span><br><span class="line">    }</span><br><span class="line"></script></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>启动项目访问 <a href="http://p95rqj.natappfree.cc/" target="_blank" rel="noopener">http://p95rqj.natappfree.cc/</a> 具体地址看自己映射,这里我们选了个比较霸气大头的图标。</p><p><img alt data-src="/img/wechat/A920CE72-CA35-4DF9-A93E-267F108720FA.png" class="lozad"></p><p>点击图标之后弹出我们常见的授权地址,只能用创建应用的QQ登录测试。</p><p><img alt data-src="/img/wechat/ADB63E15-F438-450C-BEC9-6890F33EAE55.png" class="lozad"></p><p>选择登录的QQ之后选择登录会进入我们的回调<a href="http://p95rqj.natappfree.cc/callback" target="_blank" rel="noopener">http://p95rqj.natappfree.cc/callback</a> 回调地址会携带code和state,这里我们代码只选择返回用户信息。</p><p><img alt data-src="/img/wechat/EE4396A7-968A-44A6-AABB-D6534C2AF359.png" class="lozad"></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>控制器层代码中HttpClientUtil 和 GsonUtil 、HttpClientDto并未贴出需要从GitHub中获取地址在下方。<br>实际上获取授权地址中的response_type,虽然官方文档指定说是code,但是我看jsdk里面写的是token但是里面返回的参数未不包含refresh_token,后端代码不确定这样做是否符合,这边和大家分享一下。</p><p><img alt data-src="/img/wechat/2D883913-6107-4F3A-A105-5DF5E351FFDB.png" class="lozad"></p><p>具体错误码返回和资源下载、授权流程可以看官方<a href="https://wiki.connect.qq.com/" target="_blank" rel="noopener">https://wiki.connect.qq.com/</a></p><blockquote><p>项目地址:<a href="https://github.com/LJYYAnimo/SpringBoot-Quick-start/tree/master/SpringBoot-QQ" target="_blank" rel="noopener">https://github.com/LJYYAnimo/SpringBoot-Quick-start/tree/master/SpringBoot-QQ</a></p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信H5网页授权</title>
      <link href="/3224537735.html"/>
      <url>/3224537735.html</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="授权步骤"><a href="#授权步骤" class="headerlink" title="授权步骤"></a>授权步骤</h1><ul><li><p>用户同意授权，获取code</p></li><li><p>通过code换取网页授权access_token</p></li><li><p>拉取用户信息(需scope为 snsapi_userinfo)</p></li></ul><h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><ul><li><p>SpringBoot:2.1.4.RELEASE</p></li><li><p>weixin-java-mp:3.4.0</p></li></ul><h1 id="公众测试号申请"><a href="#公众测试号申请" class="headerlink" title="公众测试号申请"></a>公众测试号申请</h1><p>开发文档:<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432</a></p><p><img alt data-src="/img/wechat/one.png" class="lozad"></p><p>由于我这边申请过了所以不做过多演示,这里我们需要注意几个地方,我们如果不适用JDSK的话只需要关注红色方框的地方,如果需要使用JSDK如调用相机、分享等。</p><p><img alt data-src="/img/wechat/74419A73-C6A7-4A51-9960-5B42CEB0E8D7.png" class="lozad"></p><p>其次测试号微信授权需要配置回调域名所以我们需要配置Natapp映射的域名,这里配置的地址只需要域名,配置在页面服务->网页账号->修改。</p><p><img alt data-src="/img/wechat/BD2B0CB8-CA15-4DE3-84F9-0AC421900F17.png" class="lozad"></p><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><p>核心pom.xml。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><dependency></span><br><span class="line">  <groupId>com.github.binarywang</groupId></span><br><span class="line">  <artifactId>weixin-java-mp</artifactId></span><br><span class="line">  <version>3.4.0</version></span><br><span class="line"></dependency></span><br></pre></td></tr></tbody></table></figure><p>核心application.yml。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wechat:</span><br><span class="line">  appId: #appId</span><br><span class="line">  appSecret: #appSecret</span><br><span class="line">  token: #服务器消息token</span><br><span class="line">  aesKey: #aesKey</span><br><span class="line">projecturl:</span><br><span class="line">  projectUrl: #natapp调试地址</span><br></pre></td></tr></tbody></table></figure><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>以下配置类@Data使用了Lombok文章中没有说明配置的话自己百度或者自己写GetSet。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 可以放一些微信相关的配置属性</span><br><span class="line">*/</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = "wechat")</span><br><span class="line">@Data</span><br><span class="line">public class WeChatAccountConfig {</span><br><span class="line">    /**</span><br><span class="line">     * 设置微信公众号的appid</span><br><span class="line">     */</span><br><span class="line">    private String appId;</span><br><span class="line">    /**</span><br><span class="line">     * 设置微信公众号的app secret</span><br><span class="line">     */</span><br><span class="line">    private String appSecret;</span><br><span class="line">    /**</span><br><span class="line">     * 设置微信公众号的token</span><br><span class="line">     */</span><br><span class="line">    private String token;</span><br><span class="line">    /**</span><br><span class="line">     * 设置微信公众号的EncodingAESKey</span><br><span class="line">     */</span><br><span class="line">    private String aesKey;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 项目公用一些API地址</span><br><span class="line">*/</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = "projecturl")</span><br><span class="line">@Data</span><br><span class="line">public class ProjectUrlConfig {</span><br><span class="line">    /**</span><br><span class="line">     * 项目访问URL</span><br><span class="line">     */</span><br><span class="line">    private String projectUrl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="SDK配置类"><a href="#SDK配置类" class="headerlink" title="SDK配置类"></a>SDK配置类</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class WeChatMpServerConfig {</span><br><span class="line">    @Autowired</span><br><span class="line">    private WeChatAccountConfig weChatAccountConfig;</span><br><span class="line">    @Bean</span><br><span class="line">    public WxMpService wxMpService(){</span><br><span class="line">        WxMpService wxMpService = new WxMpServiceImpl();</span><br><span class="line">        wxMpService.setWxMpConfigStorage(wxMpConfigStorage());</span><br><span class="line">        return wxMpService;</span><br><span class="line">    }</span><br><span class="line">    @Bean</span><br><span class="line">    public WxMpConfigStorage wxMpConfigStorage(){</span><br><span class="line">        WxMpInMemoryConfigStorage wxMpConfigStorage = new WxMpInMemoryConfigStorage();</span><br><span class="line">        wxMpConfigStorage.setAppId(weChatAccountConfig.getAppId());</span><br><span class="line">        wxMpConfigStorage.setSecret(weChatAccountConfig.getAppSecret());</span><br><span class="line">        return wxMpConfigStorage;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个配置类的由来主要是因为WxMpService接口有多个实现类自动注入的话IOC不知道使用哪个实现类,还有就是每次调用API接口如查用户、素材之类。每次之前都要设置一个wxMpConfigStorage,所以我们这里使用了一个组件来管理相关的Bean配置。</p><h2 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping("/oauth/")</span><br><span class="line">public class WeChatOAuthController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectUrlConfig projectUrlConfig;</span><br><span class="line">    @Autowired</span><br><span class="line">    private WxMpService wxMpService;</span><br><span class="line">    /**</span><br><span class="line">     * 构造网页授权URL</span><br><span class="line">     * https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect</span><br><span class="line">     *</span><br><span class="line">     * @Param returnUrl 可以传入微信端应用地址</span><br><span class="line">     */</span><br><span class="line">    @GetMapping("authorization")</span><br><span class="line">    public String authorizationUrl(@RequestParam(value = "returnUrl",defaultValue = "STATE") String returnUrl){</span><br><span class="line">        String url = projectUrlConfig.getProjectUrl()+"/oauth/userInfo";</span><br><span class="line">        String redirectUrl = wxMpService.oauth2buildAuthorizationUrl(url, WxConsts.OAuth2Scope.SNSAPI_USERINFO, URIUtil.encodeURIComponent(returnUrl));</span><br><span class="line">        return "redirect:"+redirectUrl;</span><br><span class="line">    }</span><br><span class="line">    @GetMapping("userInfo")</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String userInfo(@RequestParam("code") String code,@RequestParam("state") String state){</span><br><span class="line">        WxMpOAuth2AccessToken auth2AccessToken;</span><br><span class="line">        WxMpUser wxMpUser;</span><br><span class="line">        try {</span><br><span class="line">            auth2AccessToken = wxMpService.oauth2getAccessToken(code);</span><br><span class="line">            wxMpUser = wxMpService.oauth2getUserInfo(auth2AccessToken,null);</span><br><span class="line">        } catch (WxErrorException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new ProjectException(ResultEnum.WECHAT_ERROR.getCode(),e.getMessage());</span><br><span class="line">        }</span><br><span class="line">        return "你好！"+wxMpUser.getNickname()+",openId="+auth2AccessToken.getOpenId();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中我们大体的可以看出authorizationUrl接口是用户在微信端点击的授权API其次方法中才是构建微信授权链接让项目自己去重定向之后会到回调地址userInfo接口这里大家可以自由发挥返回前端页面也可以。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>下方就是微信授权访问接口中的方法和官方参数解析。</p><p><img alt data-src="/img/wechat/BA5A6320-223A-4CE2-A97E-1D8575BE0B3E.png" class="lozad"></p><p><img alt data-src="/img/wechat/B6A77CA0-D907-4981-8024-BACB3A1A20F9.png" class="lozad"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?</span><br><span class="line">appid=APPID&</span><br><span class="line">redirect_uri=REDIRECT_URI&</span><br><span class="line">response_type=code&</span><br><span class="line">scope=SCOPE&</span><br><span class="line">state=STATE#wechat_redirect</span><br></pre></td></tr></tbody></table></figure><p>项目启动之后我们需要把外部访问请求发送到自己的测试公众号前提需要关注。<br><img alt data-src="/img/wechat/4E9587DA-CC77-49E7-BE8C-9162ACB1E634.png" class="lozad"></p><p><img alt data-src="/img/wechat/E389D301-F12D-4B04-AD9B-F73F85D25838.png" class="lozad"></p><p>以上就是用户授权的操作一般在公众号开发嵌入H5网页常用的第一步还有就是jdsk验证也需要这里不细讲可以百度相关教程,使用了此SDK之后不需要自己去封装一些API操作简便了微信开发。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> H5 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
